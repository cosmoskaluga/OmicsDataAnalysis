[["index.html", "Omics Data Analysis Chapter 1 Introduction 1.1 How to deal with R 1.2 Assignment and grading", " Omics Data Analysis Dmitrii Smirnov, Skolkovo Institute of Science and Technology 2024-03-27 Chapter 1 Introduction This bookdown will consist of three seminars for the following lectures delivering at “Omics Data Analysis” course at Skolkovo Institute of Science and Technology: Lecture 4: Differential Expression Analysis Lecture 9: Transcriptome Assembly Lecture 13: Lipidomics Data Analysis 1.1 How to deal with R Here is an brief guideline how to work with R on the course computational cluster or your own computer: https://docs.google.com/document/d/1vyR7T7nHnWgRfQPntLU3U2jaZFJia8zH/edit?usp=sharing&amp;ouid=118110925940360211775&amp;rtpof=true&amp;sd=true If your are not familiar with R programming language, you may find the following links useful: R-intro: https://cran.r-project.org/doc/manuals/r-release/R-intro.html Learning Statistics with R: https://learningstatisticswithr.com/book/introR.html Stepik course (in Russian): https://stepik.org/course/497/promo 1.2 Assignment and grading When you complete all the tasks please upload to Canvas: Report with plots, pictures, answers and explanations. Your code (txt/pdf/R markdown or something else readable) How it will be graded: * The maximum is 7 points. For missing step - minus 3.5 points. If the report/code is missing - 0 points. For each missing figure/plot - minus 2 points. For each missing answer to ❓ - minus 2 points. For any other mistake - minus 0.2 point. "],["input-dataset.html", "Chapter 2 Input dataset 2.1 Count table importing 2.2 DESeq2 object", " Chapter 2 Input dataset Today we will focus on the differential gene expression analysis to study the gene expression signatures of microglia from accelerated aging mice subjected to PBS (phosphate buffered saline) and LPS (lipopolysaccharides, activated microglia) treatments from Zhang et al., 2022 (https://doi.org/10.1186/s12974-022-02463-5). Our dataset includes 2 experimental groups of replicates: Control and KO microglia, where KO group corresponds to to the model of accelerated aging, caused by deficiency of the DNA-repair associated gene Ercc1. One half of the samples in each group we additionally treated with PBS and another half were treated with LPS to achieve pro-inflammatory microglial activation. Raw reads were already preprocessed by the authors of the original study, therefore we can skip a large part devoted to raw read processing and mapping (Figure 1), that you already studied during the previous lecture and start with a table of counts. The input dataset is accessible here: Course server: /home/d.smirnov/homework4/Data/Data.csv Yandex disk: https://disk.yandex.ru/d/2X3QgYRa5iqcFw Figure 1. DE analysis typical workflow Import libraries: library(dplyr) library(ggplot2) library(DESeq2) library(DOSE) library(pheatmap) library(tibble) library(clusterProfiler) 2.1 Count table importing We will start the analysis with uploading raw count data to the R workspace. data &lt;- read.csv(&quot;data/Data.csv&quot;, row.names = 1) The gene expression table has gene names in the rows and samples names in the columns. ‘Length’ column denotes a length of each annotated gene: paged_table(head(data)) Further we will need a meta table which maps our samples to the corresponding sample groups that we are investigating. Our metadata will include three columns of interest: “Genotype”, “Treatment” and “SampleID”. meta &lt;- colnames(data) %&gt;% .[-c(1)] %&gt;% strsplit(split = &#39;_&#39;) %&gt;% as.data.frame() %&gt;% t() rownames(meta) &lt;- colnames(data)[-c(1)] colnames(meta) &lt;- c(&quot;Genotype&quot;, &quot;Treatment&quot;, &quot;SampleID&quot;) meta &lt;- as.data.frame(meta) Check the generated meta table: knitr::kable(meta) Genotype Treatment SampleID KO_PBS_642 KO PBS 642 KO_PBS_641 KO PBS 641 KO_PBS_638 KO PBS 638 KO_LPS_600 KO LPS 600 KO_LPS_194 KO LPS 194 KO_LPS_193 KO LPS 193 Control_PBS_175 Control PBS 175 Control_PBS_171 Control PBS 171 Control_PBS_170 Control PBS 170 Control_LPS_185 Control LPS 185 Control_LPS_184 Control LPS 184 Control_LPS_149 Control LPS 149 Another important step is a filtering of the low- and non-expressed genes prior statistical analysis. Such genes contributes to the False Discovery Rate. We will keep only those genes having at least 10 counts in total across experimental replicates. data &lt;- data[rowSums(data[,-c(1)]) &gt; 10, ] 2.2 DESeq2 object Let’s start the main part of the analysis with creating the DESeqDataSet object. To create this object we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have two column we are interested in, that is \\(\\sim Treatment + Genotype\\). The \\(Genotype\\) is the main factor of interest, therefore it is in the end of the design formula. Create DESeq2Dataset object: dds &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Treatment + Genotype) ## converting counts to integer mode ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design formula are characters, converting to factors Check what is inside the object: dds ## class: DESeqDataSet ## dim: 22783 12 ## metadata(1): version ## assays(1): counts ## rownames(22783): ENSMUSG00000051951 ENSMUSG00000103377 ... ENSMUSG00000063897 ENSMUSG00000095742 ## rowData names(0): ## colnames(12): KO_PBS_642 KO_PBS_641 ... Control_LPS_184 Control_LPS_149 ## colData names(3): Genotype Treatment SampleID "],["cross.html", "Chapter 3 Normalization and Quality control 3.1 Normalization 3.2 Quality control", " Chapter 3 Normalization and Quality control 3.1 Normalization The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. To perform the median of ratios method of normalization1, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. Perform normalization: dds &lt;- estimateSizeFactors(dds) We can take a look at the normalization factor applied to each sample: sizeFactors(dds) ## KO_PBS_642 KO_PBS_641 KO_PBS_638 KO_LPS_600 KO_LPS_194 KO_LPS_193 Control_PBS_175 Control_PBS_171 Control_PBS_170 Control_LPS_185 ## 1.2295376 0.7077297 1.1883411 0.9626383 0.7803893 1.1168247 1.3162828 1.0183880 1.0247178 0.9783637 ## Control_LPS_184 Control_LPS_149 ## 1.0500173 0.9531096 Now, to retrieve the normalized counts matrix from dds, use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized=TRUE) These normalized counts are useful for the QC and visualization purposes, but the step with estimateSizeFactors() is done automatically by DESeq2 during differential expression analysis. 3.2 Quality control Next, we perform QC checks on the count data to help us ensure that the samples/replicates look good. To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. When using these unsupervised clustering methods, transformation of the normalized counts may improve the distances/clustering for visualization. First, let’s try the most simple method of log2 transformation and plot counts of the two first KO_PBS replicates as a scatter plot: nts &lt;- log2(assay(dds, normalized = TRUE)+1) ggplot(as.data.frame(nts), aes(x = KO_PBS_642, y = KO_PBS_641)) + geom_point()+ ggtitle(&#39;log2(x+1) transformation&#39;)+ theme_dose(16) Above you can see a nice example of heteroscedasticity in the data, illustrating the dependence of the variance on the mean count value. Instead, DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. Perform rlog-transformation: rld &lt;- rlog(dds, blind = TRUE) And this is how data looks like after rlog transformation: ggplot(as.data.frame(assay(rld)), aes(x = KO_PBS_642, y = KO_PBS_641)) + geom_point()+ ggtitle(&#39;rlog transformation&#39;)+ theme_dose(16) 3.2.1 Principal Component Analysis (PCA) PCA is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). We would expect that biological replicates cluster together on PC1 and/or PC2, and the samples from different treatment groups cluster separately. DESeq2 has a built-in function for plotting PCA plots, that uses ggplot2. It takes the rlog object as an input directly. The function plotPCA requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in). Below we will create a custom function to plot PCA: plotPCA.mystyle &lt;- function (object, ntop = 500, returnData = FALSE) { font.size &lt;- 18 rv &lt;- rowVars(assay(object)) r &lt;- assay(object) select &lt;- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))] pca &lt;- prcomp(t(assay(object)[select, ])) percentVar &lt;- pca$sdev^2/sum(pca$sdev^2) d1 &lt;- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], Genotype = meta$Genotype, Treatment = meta$Treatment, name = colnames(object)) ggplot(data = d1, aes_string(x = &quot;PC1&quot;, y = &quot;PC2&quot;)) + geom_point(aes_string(color = &quot;Genotype&quot;, shape = &quot;Treatment&quot;), size = 6) + xlab(paste0(&quot;PC1: &quot;, round(percentVar[1] * 100), &quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;, round(percentVar[2] * 100), &quot;% variance&quot;)) + theme_dose(font.size = font.size)+ #+ geom_label_repel(aes(label = colnames(data)), label.size = 0.1, box.padding = 0.2) theme( legend.key = element_rect(colour = NA, fill = NA), legend.title= element_blank(), legend.text=element_text(size=font.size-2) ) } Plot PCA graph: plotPCA.mystyle(rld) By default the function plotPCA.custom uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. Task 1: In the example above, we just plotted the graph for PC1 and PC2 values. Please change the function plotPCA.mystyle so it can produce score plots for PC1 and PC3. Also, provide an obtained plot and a brief explanation of it. (1 point). 3.2.2 Correlation Heatmap The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. Extract the rlog matrix from the object: rld_mat &lt;- assay(rld) Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: rld_cor &lt;- cor(rld_mat) Plot the correlation values as a heatmap: pheatmap(rld_cor, annotation = meta[,c(1,2)]) If you forgot how this method works you may check the lecture slides or watch this video: ↩︎ "],["differential-testing.html", "Chapter 4 Differential testing 4.1 DE analysis 4.2 Extracting significant genes", " Chapter 4 Differential testing Before the differential expression analysis we will combine \\(Genotype\\) and \\(Treatment\\) factors into one column, to create four groups for the design formula: meta$Factors &lt;- paste(meta$Genotype, meta$Treatment, sep = &#39;_&#39;) meta$Factors &lt;- factor(meta$Factors, levels = c(&quot;Control_PBS&quot;, &quot;Control_LPS&quot;, &quot;KO_PBS&quot;, &quot;KO_LPS&quot;)) Now re-create the DESeqDataSet object, but this time with a design formula consisting of \\(~Factors\\): dds_factors &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Factors) ## converting counts to integer mode Here we have only one factor for design formula, consisting of four different levels (Control_PBS, Control_LPS, KO_PBS, KO_LPS). In terms of linear models, the specified formula can be expressed as \\[expression = \\beta_0 + \\beta_1 Factor_{Control\\_LPS} + \\beta_2 Factor_{KO\\_PBS} + \\beta_3 Factor_{KO\\_LPS}\\] or in matrix notations: \\[\\, \\begin{pmatrix} Y_1\\\\ Y_2\\\\ \\vdots\\\\ Y_N \\end{pmatrix} = \\begin{pmatrix} 1 &amp;x_{11} &amp; x_{12} &amp; x_{13}\\\\ 1 &amp;x_{21} &amp; x_{22} &amp; x_{23}\\\\ \\vdots\\\\ 1 &amp; x_{N1} &amp; x_{N2} &amp; x_{N3} \\end{pmatrix} \\begin{pmatrix} \\beta_0\\\\ \\beta_1\\\\ \\beta_2\\\\ \\beta_3 \\end{pmatrix} + \\begin{pmatrix} \\varepsilon_1\\\\ \\varepsilon_2\\\\ \\vdots\\\\ \\varepsilon_N \\end{pmatrix} \\] where \\(X_{N\\times4}\\) is the design matrix, \\(\\mathbf{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3)^T\\) are estimated coefficients (log2 Fold Changes) and \\(\\mathbf{\\varepsilon} = (\\varepsilon_1, \\varepsilon_2, ..., \\varepsilon_N)^T\\) are residuals. Let’s check the model matrix in dds object: model.matrix(design(dds_factors), data = colData(dds_factors)) ## (Intercept) FactorsControl_LPS FactorsKO_PBS FactorsKO_LPS ## KO_PBS_642 1 0 1 0 ## KO_PBS_641 1 0 1 0 ## KO_PBS_638 1 0 1 0 ## KO_LPS_600 1 0 0 1 ## KO_LPS_194 1 0 0 1 ## KO_LPS_193 1 0 0 1 ## Control_PBS_175 1 0 0 0 ## Control_PBS_171 1 0 0 0 ## Control_PBS_170 1 0 0 0 ## Control_LPS_185 1 1 0 0 ## Control_LPS_184 1 1 0 0 ## Control_LPS_149 1 1 0 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 1 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$Factors ## [1] &quot;contr.treatment&quot; 4.1 DE analysis All the steps of differential expression analysis can be done with a single call of the function DESeq(): dds_analysis &lt;- DESeq(dds_factors) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing Plot dispersion estimates: plotDispEsts(dds_analysis) To tell DESeq2 which groups we wish to compare, we supply the contrasts we would like to make using the contrast argument. contrast_pbs &lt;- c(&quot;Factors&quot;, &quot;KO_PBS&quot;, &quot;Control_PBS&quot;) contrast_lps &lt;- c(&quot;Factors&quot;, &quot;KO_LPS&quot;, &quot;Control_LPS&quot;) To build our results table we will use the results() function. res_unshrunken_pbs &lt;- results(dds_analysis, contrast=contrast_pbs, alpha = 0.05) res_unshrunken_lps &lt;- results(dds_analysis, contrast=contrast_lps, alpha = 0.05) To generate more accurate log2 fold change estimates, DESeq2 allows for the shrinkage of the log2 fold changes estimates toward zero when the information for a gene is low. res_pbs &lt;- lfcShrink(dds_analysis, contrast=contrast_pbs, res=res_unshrunken_pbs, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 res_lps &lt;- lfcShrink(dds_analysis, contrast=contrast_lps, res=res_unshrunken_lps, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 Check the DE results for the first comparison with PBS-treated samples: knitr::kable(head(res_pbs)) baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000051951 2.199116 0.2995143 0.5564338 0.9654189 0.3343350 NA ENSMUSG00000103377 1.543252 0.0000000 0.4451238 0.0000000 1.0000000 NA ENSMUSG00000103147 3.357070 -0.0725694 0.6653448 -0.1112250 0.9114379 NA ENSMUSG00000102331 2.149170 0.0000000 0.5917914 0.0000000 1.0000000 NA ENSMUSG00000102269 3.156919 0.7515637 0.6858511 1.0678169 0.2856031 NA ENSMUSG00000098104 66.394760 -0.0247357 0.3279316 -0.0756924 0.9396638 0.9780991 What are the columns of this table? baseMean is the mean gene expresion across all the samples in the data log2FoldChange represents differences for the comparison of interest (estimated \\(\\beta_i\\) coefficient) lfcSE is an uncertainty of \\(\\beta\\) estimate (\\(\\sigma_{\\beta_i}\\)), represented by standard error (SE) for the log2(Fold Change) stat is Z-statistic, also can be expressed as \\(Z = \\frac{\\beta_i}{\\sigma_{\\beta_i}}\\) pvalue means the raw p-value, derived from Wald Z-test, where \\(Z \\sim N(0, 1)\\), used to reject or accept the \\(H_0: \\beta_i = 0\\) padj is an adjusted p-value (FDR) To illustrate the effect of log2 foldchange shrinkage we will use the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored. plotMA(res_pbs, ylim=c(-3,5)) Task 2: Plot the unshrunken results and save the plot as pdf. Are there any differences between unshrunken and shrunken results? Provide a brief explanation (1 point). Check the results summary for PBS and LPS comparisons: summary(res_pbs, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 1658, 7.3% ## LFC &lt; 0 (down) : 1366, 6% ## outliers [1] : 58, 0.25% ## low counts [2] : 3976, 17% ## (mean count &lt; 4) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results summary(res_lps, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 2604, 11% ## LFC &lt; 0 (down) : 2650, 12% ## outliers [1] : 58, 0.25% ## low counts [2] : 3534, 16% ## (mean count &lt; 3) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results 4.2 Extracting significant genes Now we are ready to extract significant differentially expressed genes. We will define significant genes as those satisfying the |FDR p-value &lt; 0.05| and |log2(Fold Change)| &gt; 0.58: padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 Convert the results table into a tibble: res_pbs_tb &lt;- res_pbs %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() res_lps_tb &lt;- res_lps %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() Select significant genes: sig_pbs &lt;- res_pbs_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) sig_lps &lt;- res_lps_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) knitr::kable(head(sig_pbs)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.659849 -0.6181067 0.1498275 -4.125052 0.0000371 0.0006525 ENSMUSG00000098234 124.162031 1.2350160 0.3683580 3.356822 0.0007884 0.0081581 ENSMUSG00000104170 6.110599 -2.0618887 0.6755101 -3.124092 0.0017835 0.0158482 ENSMUSG00000082193 893.899515 0.6408058 0.1318862 4.858817 0.0000012 0.0000349 ENSMUSG00000043716 4483.398050 0.6343141 0.0997568 6.358617 0.0000000 0.0000000 ENSMUSG00000025921 339.426837 -0.7060598 0.2085612 -3.383875 0.0007147 0.0075408 knitr::kable(head(sig_lps)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.65985 -0.6522115 0.1512123 -4.313504 0.0000161 0.0001486 ENSMUSG00000103845 108.10608 -0.9919058 0.2279104 -4.353331 0.0000134 0.0001269 ENSMUSG00000076135 45.67683 0.8741142 0.3262561 2.675267 0.0074670 0.0302701 ENSMUSG00000061024 643.74312 0.6301914 0.1734137 3.632947 0.0002802 0.0018652 ENSMUSG00000079671 285.23809 -1.1868063 0.2880284 -4.125537 0.0000370 0.0003128 ENSMUSG00000098234 124.16203 0.9715333 0.3633901 2.668152 0.0076270 0.0307757 Intriguingly, the number of significant genes is almost twice more in the comparison with LPS compared to PBS-treated data. nrow(sig_pbs) ## [1] 2039 nrow(sig_lps) ## [1] 4045 Task 3: Perform DE analysis comparing LPS and PBS profiles: Control_LPS vs Control_PBS and KO_LPS vs KO_PBS. How many DE genes (FDP P-value &lt; 0.05 and |log2FC|&gt; 0.58) did you obtain for these comparisons (1 point). "],["gene-annotation.html", "Chapter 5 Gene annotation", " Chapter 5 Gene annotation Gene features in both input and DE tables are represented with their ENSEMBL identifiers, but it would be also useful to obtain an information about corresponding gene names, ENTREZ IDs and other types of description. To perform Gene ID conversion we will use mouse genome annotation from org.Mm.eg.db package library(org.Mm.eg.db) Use select() function to convert ENSEMBL IDs to gene names (“SYMBOL”) and Entrez identifiers (“ENTREZID”) mm &lt;- org.Mm.eg.db my.symbols &lt;- res_pbs_tb$gene map &lt;- select(mm, keys = my.symbols, columns = c(&quot;ENTREZID&quot;, &quot;SYMBOL&quot;, &quot;ENSEMBL&quot;), keytype = &quot;ENSEMBL&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns You could also notice warning 'select()' returned 1:many mapping between keys and columns, meaning that some genes have non-unique mapping between IDs. For example, Zfp969 genes has multiple ENSEMBL annotations: filter(map, SYMBOL == &#39;Zfp969&#39;)$ENSEMBL ## [1] &quot;ENSMUSG00000078898&quot; &quot;ENSMUSG00000095545&quot; &quot;ENSMUSG00000089756&quot; &quot;ENSMUSG00000095199&quot; In addition, ENSMUSG00000078898 was also mapped to multiple gene names: filter(map, ENSEMBL == &#39;ENSMUSG00000078898&#39;)$SYMBOL ## [1] &quot;Zfp968&quot; &quot;Zfp969&quot; First, we will combine DE result tables with the obtained gene annotation: res_pbs_tb &lt;- left_join(res_pbs_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) res_lps_tb &lt;- left_join(res_lps_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) Now DESeq2 output tables have two additional columns: paged_table(head(res_pbs_tb)) Next, we will get rid of duplicated ENSEMBL IDs: res_pbs_tb &lt;- res_pbs_tb[!duplicated(res_pbs_tb$gene),] res_lps_tb &lt;- res_lps_tb[!duplicated(res_lps_tb$gene),] Check if the number of genes in the output tables for both comparisons is equal: nrow(res_pbs_tb) == nrow(res_lps_tb) ## [1] TRUE Finally, get the annotation only for the differentially expressed genes: sig_pbs &lt;- res_pbs_tb %&gt;% filter(gene %in% sig_pbs$gene) sig_lps &lt;- res_lps_tb %&gt;% filter(gene %in% sig_lps$gene) "],["visualization.html", "Chapter 6 Visualization 6.1 Volcano plot 6.2 Heatmap of significant genes 6.3 Comparison with DAM markers", " Chapter 6 Visualization Once we obtained the lists of differentially expressed genes for each condition, it would be good to make sense of them. This chapter is devoted to the visual representation of DE results, that greatly helps with results interpretation. 6.1 Volcano plot The most standard way to visualize the obtained gene expression changes is volcano plot. This plot shows the direction of gene expression changes (up- or down-regulated) and also highlight the top DE genes. We will utilize EnhancedVolcano library: library(EnhancedVolcano) The volcano plot requires the information about gene log2(Fold Changes) for X-axis and corresponding adjusted p-values, plotted in Y-axis. In addition, you may specify the column in the DE table that can be used for gene annotation in the plot. Code below will execute EnhancedVolcano() function: p1 &lt;- EnhancedVolcano(res_pbs_tb, lab = res_pbs_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, PBS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) p2 &lt;- EnhancedVolcano(res_lps_tb, lab = res_lps_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, LPS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) cowplot::plot_grid(p1, p2, nrow = 1) 6.2 Heatmap of significant genes Another way to visualize DE genes and their changes in expression is using heatmap We also will extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap() function: Convert normalized_counts to a data frame and transfer the row names to a new column called “gene” normalized_counts &lt;- counts(dds_analysis, normalized = T) %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) Extract normalized expression for significant genes: norm_sig_pbs &lt;- normalized_counts %&gt;% filter(gene %in% sig_pbs$gene) %&gt;% column_to_rownames(&#39;gene&#39;) norm_sig_lps &lt;- normalized_counts %&gt;% filter(gene %in% sig_lps$gene) %&gt;% column_to_rownames(&#39;gene&#39;) Plot the heatmap: pheatmap(norm_sig_pbs, cluster_rows = T, show_rownames = F, annotation = meta[,c(1,2)], border_color = NA, fontsize = 10, scale = &quot;row&quot;, fontsize_row = 10, height = 10) 6.3 Comparison with DAM markers Disease-associated-microglia (DAM) is a microglia type associated with various neurodegeneration diseases (AD, ALS, aging) and characterized by a specific transcriptional program. We will work with DAM signatures described in Deczkowska et al., 2018 (https://doi.org/10.1016/j.cell.2018.05.003) and in the Figure 2. This signatures can be divided in three main groups or stages: markers of homeostatic microglia, Stage 1 DAM (independent on TREM2 signaling) signatures and markers of Stage 2 DAM of microglial activation, caused by TREM2 signaling. Figure 2: DAM stages in mouse: homeostatic microglia -&gt; Stage DAM 1 -&gt; Stage DAM 2. Figure was taken from Deczkowska et al., 2018. Task 4: Analyze changes in expression of DAM marker genes in the both PBS and LPS comparisons. Plot a heatmap of the DAM signature expression levels (0.5 points) and volcano plots for expression changes in DAM signatures for both comparisons (0.5 points). Do the observed changes in your data correspond to the changes in disease-associated microglia? Provide an explanation (0.5 points). "],["functional-analysis.html", "Chapter 7 Functional analysis 7.1 Gene Ontology (GO) analysis 7.2 Pathway analysis 7.3 Gene-Set Enrichment Analysis (GSEA) 7.4 Gene Set Enrichment Analysis with mSigDB", " Chapter 7 Functional analysis The main idea of the functional analysis is to connect observed changes in gene expression with associated altered cellular pathways and biological functions. Below we will try the most well-known methods allowing to gain some insight into biological interpretation of the obtained DE results. 7.1 Gene Ontology (GO) analysis Gene Ontology analysis is probably the most popular and widely-used method. The hypergeometric test, that is identical to one-sided Fisher’s exact test, is typically used for over-representation analysis and the p-value of the significance is calculated in the following way: \\[ p = 1 - \\sum_{i = 0}^{k-1} \\frac{\\binom{M}{i} \\binom{N-M}{n-i}}{\\binom{N}{n}} \\] where \\(N\\) is a total number of genes in the background \\(M\\) is a number of genes in the background that are also in the GO category \\(n\\) is a total number of DE genes \\(k\\) is number of DE genes that are also in the GO category While the over-representation analysis can be easily done with many packages in R, the most popular is ClusterProfiler. GO analysis with ClusterProfiler can be easily done with enrichGO function: ego_pbs &lt;- enrichGO(gene = sig_pbs$gene, universe = res_pbs_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) ego_lps &lt;- enrichGO(gene = sig_lps$gene, universe = res_lps_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) We will use boxplots to visualize the enriched categories: cowplot::plot_grid(barplot(ego_pbs), barplot(ego_lps), nrow = 1) 7.2 Pathway analysis Over-representation analysis using reference data on KEGG pathways can be done in a similar way, but now we must use enrichKEGG function and utilize NCBI ENTREZ IDs as input: ekegg_pbs &lt;- enrichKEGG(gene = na.omit(sig_pbs$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe = na.omit(res_pbs_tb$ENTREZID)) ekegg_lps &lt;- enrichKEGG(gene = na.omit(sig_lps$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe = na.omit(res_lps_tb$ENTREZID)) Note: If you work on the course computational cluster, you can encounter the error “No gene can be mapped …”. This issue is incompatibility between the currently installed clusterProfiler version and KEGG database. Here we suggest a workaround to avoid this problem: install.packages(&quot;/home/d.smirnov/KEGG.db_1.0.tar.gz&quot;, repos=NULL, type=&quot;source&quot;) # run this in terminal library(KEGG.db) ekegg_pbs &lt;- enrichKEGG(gene = na.omit(sig_pbs$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe = na.omit(res_pbs_tb$ENTREZID), use_internal_data = T) ekegg_lps &lt;- enrichKEGG(gene = na.omit(sig_lps$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe = na.omit(res_lps_tb$ENTREZID), use_internal_data = T) ## Now the output of the enrichKEGG() is generated, but the Description column consist of NAs. ## We will add missing pathway names manually from the KEGG.db we just uploaded. ekegg_pbs@result$Description &lt;- unlist(as.list(&quot;KEGG.db&quot;::&quot;KEGGPATHID2NAME&quot;)[ekegg_pbs@result$ID]) ekegg_lps@result$Description &lt;- unlist(as.list(&quot;KEGG.db&quot;::&quot;KEGGPATHID2NAME&quot;)[ekegg_lps@result$ID]) Since recently, the description of KEGG pathways in the clusterProfiler output data include the part related to a species name, which is - Mus musculus .(house mouse). in this case. This annoying text complicates visualization of the enriched pathways, so we will get rid of it: ekegg_pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_pbs@result$Description) ekegg_lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_lps@result$Description) Another (and a little bit more complex) way to visualize pathway enrichment results is to use upsetplots, showing co-occurring DE gene sets in respect to the altered pathways they associated with: library(enrichplot) ups_pbs &lt;- enrichplot::upsetplot(ekegg_pbs) ups_lps &lt;- enrichplot::upsetplot(ekegg_lps) ups_pbs ups_lps 7.3 Gene-Set Enrichment Analysis (GSEA) Unlike hypergeometric distribution based methods, GSEA works in the assumption that even small and not significant, but coordinated changes in gene expression can have impact on cellular pathways. Therefore, GSEA uses statistics of all the genes in a dataset, taking log2 Fold Changes as an input. Figure 3: The general principle of GSEA. The figure was taken from Subramanian et al., (2005) https://doi.org/10.1073/pnas.0506580102 Since GSEA interpretation in clusterProfiler rely on NCBI ENTREZ IDs, we will filter out genes not annotated in ENTREZ: pbs_filtered &lt;- filter(res_pbs_tb, ENTREZID != &quot;NA&quot;) lps_filtered &lt;- filter(res_lps_tb, ENTREZID != &quot;NA&quot;) Select gene log2(Fold Changes) and assign NCBI ENTREZ IDs as names of the vectors: foldchanges.pbs &lt;- pbs_filtered$log2FoldChange names(foldchanges.pbs) &lt;- as.character(pbs_filtered$ENTREZID) foldchanges.lps &lt;- lps_filtered$log2FoldChange names(foldchanges.lps) &lt;- as.character(lps_filtered$ENTREZID) Sort fold changes: foldchanges.pbs &lt;- sort(foldchanges.pbs, decreasing = TRUE) foldchanges.lps &lt;- sort(foldchanges.lps, decreasing = TRUE) Now, we can run gseKEGG() function with sorted fold changes as input and using default parameters gseaKEGG.pbs &lt;- gseKEGG(geneList = foldchanges.pbs, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying to run fgseaSimple. It is recommended to use ## fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.21% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene names, fgsea may produce unexpected results. gseaKEGG.lps &lt;- gseKEGG(geneList = foldchanges.lps, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying to run fgseaSimple. It is recommended to use ## fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.22% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene names, fgsea may produce unexpected results. Note: If you work on the course cluster, you will have an “No gene can be mapped …” bug again. As before, use use_internal_data = T to overcome this: ## KEEG.db is already loaded gseaKEGG.pbs &lt;- gseKEGG(geneList = foldchanges.pbs, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE, use_internal_data = T) gseaKEGG.lps &lt;- gseKEGG(geneList = foldchanges.lps, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE, use_internal_data = T) gseaKEGG.pbs@result$Description &lt;- unlist(as.list(&quot;KEGG.db&quot;::&quot;KEGGPATHID2NAME&quot;)[gseaKEGG.pbs@result$ID]) gseaKEGG.lps@result$Description &lt;- unlist(as.list(&quot;KEGG.db&quot;::&quot;KEGGPATHID2NAME&quot;)[gseaKEGG.lps@result$ID]) Remove the species name in the pathway description again: gseaKEGG.pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.pbs@result$Description) gseaKEGG.lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.lps@result$Description) Check the results for both comparisons: paged_table(gseaKEGG.pbs@result) paged_table(gseaKEGG.lps@result) Apart from the adjusted p-values, enrichment score is another important characteristic of the altered pathways, reflecting the degree of which gene sets are over-represented at the top or at the bottom of the input ranked gene lists. You may find the corresponding values in enrichmentScore column of gseaKEGG.pbs and gseaKEGG.lps tables. Below is a GSEA plot for three manually selected enriched pathway from the PBS comparison: enrichplot::gseaplot2(gseaKEGG.pbs, geneSetID = c(15, 23, 29), pvalue_table = TRUE, color = c(&quot;#E495A5&quot;, &quot;#86B875&quot;, &quot;#7DB0DD&quot;), ES_geom = &quot;dot&quot;) Please note, that your enriched pathways could be different from the ones showed in the plot above! 7.4 Gene Set Enrichment Analysis with mSigDB In the section above we used GO terms and KEGG pathways to perform enrichment analyses, but sometimes it is needed to compare gene expression changes against other gene sets, such as signatures or markers of the various diseases and biological processes. A possible solution is to use Molecular Signatures Database (mSigDB) represents the curated lists of gene sets, divided in 9 main collections: H: Hallmark gene sets C1: Positional gene sets C2: Curated gene sets C3: Motif gene sets C4: Computational gene sets C5: Gene Ontology gene sets C6: Oncogenic signatures gene sets C7: Immunologic signatures C8: Cell type signatures In R this database is already available through the msigdbr package: library(msigdbr) While mSigDB contains annotated gene sets for many species (you can get a list of them with msigdbr_show_species()), we will specify ‘mouse’ to retrieve mouse-related sets for the Hallmark gene sets: msig_h &lt;- msigdbr(species = &quot;mouse&quot;, category = &quot;H&quot;) Next, prepare an input reference table for enrichment analysis: msigdbr_t2g &lt;- msig_h %&gt;% dplyr::distinct(gs_name, ensembl_gene) %&gt;% as.data.frame() This table consist of two columns, one for gene set names (specific terms) and another one for the corresponding ENSEMBL IDs: paged_table(head(msigdbr_t2g)) Run the over-presentation analysis on significant genes with prepared term-to-gene table using enricher() function: hallmarks.pbs &lt;- enricher(gene = sig_pbs$gene, TERM2GENE = msigdbr_t2g) hallmarks.lps &lt;- enricher(gene = sig_lps$gene, TERM2GENE = msigdbr_t2g) Visualize the obtained enriched terms for PBS comparison: dotplot(hallmarks.pbs) … and for LPS comparison: dotplot(hallmarks.lps) To run the GSEA analysis with mSigDB terms we must select NCBI ENTREZ IDs instead of ENSEMBL ones: msigdbr_t2g &lt;- msig_h %&gt;% dplyr::distinct(gs_name, entrez_gene) Now execute GSEA function with foldchanges.pbs gene list and re-generated term-to-gene annotation: gsea_h_pbs &lt;- GSEA(foldchanges.pbs, TERM2GENE = msigdbr_t2g) ## preparing geneSet collections... ## GSEA analysis... ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.21% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene names, fgsea may produce unexpected results. ## Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize, : For some pathways, in reality P-values are less than 1e-10. You can set the `eps` ## argument to zero for better estimation. ## leading edge analysis... ## done... Check out the enriched terms: paged_table(head(gsea_h_pbs)) An essential part of DE analysis is the validation of the obtained gene expression changes with custom gene sets, identified by other researches in similar experiments. Here we will use previously described enrichment methods to compare our changes against a list of DAM metabolites. Task 5: Perform GSEA on foldchanges.pbs and foldchanges.lps lists using DAM-related genes as an argument for TERM2GENE = ... in GSEA() function (1.5 point). Task 6: So far we did the enrichment analysis for all the obtained DE genes per comparison, but sometimes it is useful to focus on the specific groups of DE genes. For example, one can split DE gene set into down- or up-regulated subsets and test them with the enrichment methods, but in this task you will be asked to accomplish a more complicated, but, in the same time, more interesting analysis: First, perform clustering of your DE genes (you can use DE set for the comparison you prefer most) to identify groups of genes with similar expression trends. The most straightforward method here is hierarchical clustering, but you can also any other adequate gene clustering methods you like. Next, choose the number of clusters based on some criteria. It can be the Gap-Statistics, the Silhouette or any other appropriate method you like. Perform the enrichment analysis (enrichGO/enrichKEGG) on the groups of genes you like most, two or three groups will be enough. Provide the plots and also comment on the enrichment results obtained. As it was mentioned, this task is more challenging, but is it close as possible to the real research tasks relevant to the DE results interpretation. This task will give you 1 point. Have fun! "],["introduction-1.html", "Chapter 8 Introduction 8.1 Assignment and grading 8.2 Set up conda environment", " Chapter 8 Introduction Figure 2: Rana Amurensis frog During this lesson we will reconstruct transcriptome assembly for Heilongjiang brown frog (Rana amurensis) using RNA-seq data obtained from https://www.nature.com/articles/s41598-022-24631-6#data-availability. We already downloaded pair-end raw .fastq files and prepared toy datasets for you. Each pair of files (R1 and R2) constists of ~1700000 reads derived from heart, liver or muscle. First, choose your invidual dataset in a table here: https://docs.google.com/document/d/1aGLb3qV1N6Yxay0-QjzlTtZWk7JfUZYYd7drZeu7dtk/edit?usp=sharing Once you decided upon dataset to work with, you can find your paired-end fastq files, named .R1.fq.gz and .R2.fq.gz in /home/d.smirnov/homework5/data/.❗Please do not copy them to your home directory, in all steps below you should simply specify the correct path to these files. 8.1 Assignment and grading When you complete all the tasks please upload to Canvas: Report with answers and explanations. Your code (txt/pdf/markdown or something else readable) How it will be graded: The maximum is 7 points. For missing step - minus 3.5 points. If the report/code is missing - 0 points. For each missing answer to ❓ - minus 2 points. For any other mistake - minus 0.2 point. 8.2 Set up conda environment Activate trinity environment with all required tools pre-installed. /opt/anaconda3/bin/conda init conda activate trinity "],["de-novo-transcriptome-assembly.html", "Chapter 9 De novo transcriptome assembly 9.1 Read filtering 9.2 Run trinity", " Chapter 9 De novo transcriptome assembly 9.1 Read filtering The first step is to remove adapters and low-quality reads from the raw .fastq files. To do this, run TrimGalore tool: trim_galore --cores 2 --paired --gzip --fastqc --fastqc_args &quot;-t 2&quot; --output_dir data_filtered data/&lt;your_number&gt;.R1.fq.gz data/&lt;your_number&gt;.R2.fq.gz where --fastqc argument means that we also want to perform quality assessment of filtered reads via FastQC using two computational cores (as specified by --fastqc_args \"-t 2\"). 9.2 Run trinity This is the most crucial and time consuming step in the analysis. It might take several hours, therefore it make sense to launch Trinity in screen session. Create your screen session: screen -S &lt;session name&gt; Run Trinity: Trinity --seqType fq --SS_lib_type RF --max_memory 2G --left data_filtered/&lt;your_number&gt;.R1_val_1.fq.gz --right data_filtered/&lt;your_number&gt;.R2_val_2.fq.gz --CPU 2 where --SS_lib_type RF means that the library preparation was done with a first strand protocol (we know that from the original paper). Once Trinity run is finished, trinity_out_dir folder will be created. Inside it you will find Trinity.fasta reconstructed assembly and temporary files and folders generated by program during all the stages of assembling. Check the Trinity.fasta header: head Trinity.fasta The output should have the following structure: &gt;TRINITY_DN486518_c0_g1_i1 len=531 path=[0:0-530] GGGGACGGCTATGCGGCCAGTGTATGAGGAGGAGGAAGGGGAGCAACAAGACGATCATCC TGTGTTCAAGAACGGCGAACCTGATTACCAAGGCGAATACCTTTCGTGCTTTGAAGAGCC CAACCTGCTGTACCGCATTTGCAACTCGGAAGACAAAACATGGGCGTTCTATAACGATAG CCGCATCTACGAGATACATGTGCAGTTTAATTTCGGCAAGAACTCCAAGTTGCAGCCGCT TGAAAACACCAGCATGTACACGAGGAACTCGGGTGAGCATGTTGCCAGAGTCATTGTATA CCCTGGCGAAACGGAAATGTTTGTGCAGGGCACCGTTAACGGCTTCACAAGCAAGCTTCG CGCGATCCCACTTTCTGAGGAGCACCACAAGTGCCGCCAGGCAATCACTTCCGCCATGAT TGAGGAAGAGGCGAATCAGATTCGGCAGATTGTCGGGGACGCTGCAGACGCCGAGACCGC ACTGAAGGCGTGCGTTGAGAACAACATTCCGTTCGTCGACCCCGAGTTCCC "],["transcriptome-assembly-qc.html", "Chapter 10 Transcriptome assembly QC 10.1 Obtain assembly statistics 10.2 Transcript filtering 10.3 Assembly completeness with gVolante", " Chapter 10 Transcriptome assembly QC 10.1 Obtain assembly statistics Trinity has TrinityStats.pl script to compute basic assembly statistics, including N50 metrics, estimating the ‘length of the shortest contig, for which longer and equal length contigs cover at least 50 % of the assembly’ [1] TrinityStats.pl Trinity.fasta Task 1: How many trinity ‘genes’ and ‘transcripts’ did you get? (1 point). 10.2 Transcript filtering Now we want to filter out short redundant contigs that were erroneously assembled by Trinity. CD-HIT tool calculates transcript similarity values and merge transcripts based on similarity threshold of 98%. cd-hit-est -o cdhit -c 0.98 -i trinity_out_dir/Trinity.fasta -p 1 -d 0 -b 3 -T 2 -M 1000 where -p is for printing an alignment overlap in .clstr file, -b represents band_width of alignment, -T is a number of threads and -M is a memory limit (in MB). After filtering new filtered assembly will be stored in cdhit file. Rename it to avoid confusion: mv cdhit Trinity.filtered.fasta Run QC script on filtered assembly again TrinityStats.pl Trinity.filtered.fasta Task 2: How many trinity ‘transcripts’ were filtered out from the assembly? (1 point) 10.3 Assembly completeness with gVolante To assess completeness of the obtained assembly we will use gVolante web tool. Transfer filtered .fasta transcriptome to your local machine and then open https://gvolante.riken.jp/analysis.html. Upload your .fasta file, it may take few minutes: Select Coding/transcribed (nucleotide) sequence type and BUSCO v5 as a pipeline to use. Select “Tetrapoda” as an ortholog set for BUSCO v5. Then click on Start your analysis. Task 3: Report BUSCO scores (Complete and single-copy, Complete and duplicated, Fragmented, or Missing BUSCOs) and a number of assembly transcripts that are &gt; 1K in their length. (1 points) "],["quantification-and-annotation.html", "Chapter 11 Quantification and annotation 11.1 Transcript quantification 11.2 Transcript annotation 11.3 Integrating expression data and annotation", " Chapter 11 Quantification and annotation 11.1 Transcript quantification The next step is to quantify transcript abundance. Since we already have a reference transcriptome constructed by Trinity, we can align filtered RNA-seq reads on it and calculate transcript and gene expression levels. Quantify expression for both transcript and gene levels with Kallisto mode: align_and_estimate_abundance.pl --SS_lib_type RF --est_method kallisto --transcripts Trinity.filtered.fasta --seqType fq --left data_filtered/&lt;your_number&gt;.R1_val_1.fq.gz --right data_filtered/&lt;your_number&gt;.R2_val_2.fq.gz --output_dir kallisto_output --thread_count 2 --trinity_mode --prep_reference Apart from kallisto_output folder this script will also generate two additional files: Trinity.filtered.fasta.gene_trans_map and Trinity.filtered.fasta.kallisto_idx. Transcript and gene expression levels will be stored in kallisto_output/abundance.tsv and kallisto_output/abundance.tsv.genes tables, respectively. head kallisto_output/abundance.tsv target_id length eff_length est_counts tpm TRINITY_DN3897_c0_g1_i1 794 537.124 7 4.2194 TRINITY_DN3897_c1_g1_i1 581 324.353 8 7.98545 TRINITY_DN3809_c0_g1_i1 283 55.0072 2 11.7717 TRINITY_DN3844_c0_g1_i1 1149 892.124 24.4812 8.88454 TRINITY_DN3869_c0_g1_i1 417 162.011 2 3.9968 TRINITY_DN3869_c0_g2_i1 416 161.011 2 4.02162 TRINITY_DN3854_c0_g1_i1 487 230.719 1.67628 2.35229 TRINITY_DN3854_c0_g2_i1 490 233.719 3.32372 4.60423 TRINITY_DN3891_c0_g1_i1 472 215.852 3 4.49979 11.2 Transcript annotation While we already evaluated expression of each gene in the assembly, the biological interpretation of the obtained trinity features (represented like TRINITY_DN3897_c0_g1) is still a puzzle. To expand our understanding of what the assembled features are, we will perform several annotation procedures with TransDecoder and Trinotate tools. First, create Trinotate sqlite database by running the following line Build_Trinotate_Boilerplate_SQLite_db.pl Trinotate It will download uniprot_sprot.pep (protein sequence information from the SwissProt database) and Pfam-A.hmm.gz (protein domains) files. To perform blast search with uniprot_sprot.pep searches, we should prepare a BLAST database: makeblastdb -in uniprot_sprot.pep -dbtype prot Prepare Pfam database gunzip Pfam-A.hmm.gz hmmpress Pfam-A.hmm Run TransDecoder to identify the longest open reading frames (ORF) from the assembly file: TransDecoder.LongOrfs -m 10 -t Trinity.filtered.fasta ❗ The two annotation steps described below will be quite time consuming (several hours each), therefore consider using screen session. Blast against the SwissProt protein database: blastx -query Trinity.filtered.fasta -db uniprot_sprot.pep -num_threads 2 -max_target_seqs 1 -outfmt 6 &gt; blastx.outfmt6 Query a set of the longest obtained ORFs against Swiss-Prot database to search for sequence similarity with known proteins blastp -query Trinity.filtered.fasta.transdecoder_dir/longest_orfs.pep -db uniprot_sprot.pep -num_threads 2 -max_target_seqs 1 -outfmt 6 &gt; blastp.outfmt6 In addition to Blast results perform hmmscan search for protein domains from the Pfam database. Run the following line in a screen session: hmmsearch --cpu 2 -o /dev/null --domtblout hmmsearch.tmp Pfam-A.hmm Trinity.filtered.fasta.transdecoder_dir/longest_orfs.pep awk &#39;BEGIN{OFS=FS=&quot; &quot;} NR&lt;=3{print}; NR&gt;3{tmp=$1; $1=$4; $4=tmp; tmp=$2; $2=$5; $5=tmp; print}&#39; hmmsearch.tmp &gt; TrinotatePFAM.out Once all three searches are done, we can start uploading information to Trinotate.sqlite database. First, generate a gene_trans_map file, linking Trinity unigenes with associated transcripts /home/d.smirnov/homework5/get_Trinity_gene_to_trans_map.pl Trinity.filtered.fasta &gt; Trinity.filtered.fasta.gene_trans_map and then load assembly .fasta file, longest_orfs.pep and gene_trans_map file into Trinotate sqlite object: Trinotate Trinotate.sqlite init --gene_trans_map Trinity.filtered.fasta.gene_trans_map \\ --transcript_fasta Trinity.filtered.fasta \\ --transdecoder_pep Trinity.filtered.fasta.transdecoder_dir/longest_orfs.pep Load blastp, blastx and pfam results Trinotate Trinotate.sqlite LOAD_swissprot_blastp blastp.outfmt6 Trinotate Trinotate.sqlite LOAD_swissprot_blastx blastx.outfmt6 Trinotate Trinotate.sqlite LOAD_pfam TrinotatePFAM.out Finally, generate the report: Trinotate Trinotate.sqlite report &gt; trinotate_annotation_report.xls Extract GO annotation terms from the report: extract_GO_assignments_from_Trinotate_xls.pl \\ --Trinotate_xls trinotate_annotation_report.xls \\ -G --include_ancestral_terms &gt; go_annotations.txt Explore the obtained go_annotations.txt file 11.3 Integrating expression data and annotation Generate a map of trinity gene IDs and corresponding annotations Trinotate_get_feature_name_encoding_attributes.pl \\ trinotate_annotation_report.xls &gt; annot_feature_map.txt Check annot_feature_map.txt: TRINITY_DN10000_c0_g1 TRINITY_DN10000_c0_g1^VKGC_RAT TRINITY_DN10000_c0_g1_i1 TRINITY_DN10000_c0_g1_i1^VKGC_RAT TRINITY_DN10000_c1_g1 TRINITY_DN10000_c1_g1^VKGC_DELLE TRINITY_DN10000_c1_g1_i1 TRINITY_DN10000_c1_g1_i1^VKGC_DELLE TRINITY_DN10001_c0_g2 TRINITY_DN10001_c0_g2^PAR10_HUMAN TRINITY_DN10001_c0_g2_i1 TRINITY_DN10001_c0_g2_i1^PAR10_HUMAN TRINITY_DN10006_c0_g1 TRINITY_DN10006_c0_g1^NDUBB_CRIGR TRINITY_DN10006_c0_g1_i1 TRINITY_DN10006_c0_g1_i1^NDUBB_CRIGR TRINITY_DN10006_c0_g1_i2 TRINITY_DN10006_c0_g1_i2^NDUBB_CRIGR TRINITY_DN10007_c0_g1 TRINITY_DN10007_c0_g1^MRC1_HUMAN Update expression matrix with gene names: /home/d.smirnov/homework5/rename_matrix_feature_identifiers.pl kallisto_output/abundance.tsv.genes \\ annot_feature_map.txt &gt; Trinity_trans.counts.wAnnot.matrix Task 4: How many genes were annotated? (2 points) Task 5: What are the top 10 most expressed genes with defined annotation? (2 points) Task 6: Given the information about the most expressed genes in the dataset, make a guess about the tissue type from which your reads were derived. This task won’t be graded, but it is obligatory to complete it, also explaining why do you choose a particular tissue type. "],["lipidomics-data-analysis.html", "Chapter 12 Lipidomics Data Analysis", " Chapter 12 Lipidomics Data Analysis To be added. "],["references.html", "References", " References "],["session-info.html", "Chapter 13 Session Info", " Chapter 13 Session Info sessionInfo() ## R version 4.3.1 (2023-06-16) ## Platform: aarch64-apple-darwin20 (64-bit) ## Running under: macOS Ventura 13.6 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib; LAPACK version 3.11.0 ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## time zone: Europe/Moscow ## tzcode source: internal ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] msigdbr_7.5.1 enrichplot_1.20.3 EnhancedVolcano_1.18.0 ggrepel_0.9.5 org.Mm.eg.db_3.17.0 ## [6] AnnotationDbi_1.62.2 clusterProfiler_4.8.3 tibble_3.2.1 pheatmap_1.0.12 DOSE_3.26.2 ## [11] DESeq2_1.40.2 SummarizedExperiment_1.30.2 Biobase_2.60.0 MatrixGenerics_1.12.3 matrixStats_1.2.0 ## [16] GenomicRanges_1.52.1 GenomeInfoDb_1.36.4 IRanges_2.34.1 S4Vectors_0.38.2 BiocGenerics_0.46.0 ## [21] ggplot2_3.4.4 dplyr_1.1.4 rmarkdown_2.25 reactable_0.4.4 ## ## loaded via a namespace (and not attached): ## [1] RColorBrewer_1.1-3 rstudioapi_0.15.0 jsonlite_1.8.8 magrittr_2.0.3 farver_2.1.1 fs_1.6.3 ## [7] zlibbioc_1.46.0 vctrs_0.6.5 memoise_2.0.1 RCurl_1.98-1.13 ggtree_3.8.2 htmltools_0.5.7 ## [13] S4Arrays_1.0.6 gridGraphics_0.5-1 sass_0.4.8 bslib_0.6.1 htmlwidgets_1.6.4 plyr_1.8.9 ## [19] cachem_1.0.8 igraph_2.0.2 lifecycle_1.0.4 pkgconfig_2.0.3 Matrix_1.6-4 R6_2.5.1 ## [25] fastmap_1.1.1 gson_0.1.0 GenomeInfoDbData_1.2.10 digest_0.6.34 aplot_0.2.2 colorspace_2.1-0 ## [31] patchwork_1.2.0 RSQLite_2.3.5 fansi_1.0.6 httr_1.4.7 polyclip_1.10-6 abind_1.4-5 ## [37] compiler_4.3.1 bit64_4.0.5 withr_3.0.0 downloader_0.4 BiocParallel_1.34.2 viridis_0.6.5 ## [43] DBI_1.2.0 ggupset_0.3.0 ggforce_0.4.1 MASS_7.3-60 DelayedArray_0.26.7 HDO.db_0.99.1 ## [49] tools_4.3.1 ape_5.7-1 scatterpie_0.2.1 glue_1.7.0 nlme_3.1-164 GOSemSim_2.26.1 ## [55] grid_4.3.1 shadowtext_0.1.3 reshape2_1.4.4 fgsea_1.26.0 generics_0.1.3 gtable_0.3.4 ## [61] tidyr_1.3.1 data.table_1.15.0 tidygraph_1.2.3 utf8_1.2.4 XVector_0.40.0 pillar_1.9.0 ## [67] stringr_1.5.1 babelgene_22.9 yulab.utils_0.1.1 splines_4.3.1 tweenr_2.0.2 treeio_1.24.3 ## [73] lattice_0.22-5 bit_4.0.5 tidyselect_1.2.0 GO.db_3.17.0 locfit_1.5-9.8 Biostrings_2.68.1 ## [79] knitr_1.45 gridExtra_2.3 bookdown_0.37 xfun_0.42 graphlayouts_1.0.2 stringi_1.8.3 ## [85] lazyeval_0.2.2 ggfun_0.1.3 yaml_2.3.8 evaluate_0.23 codetools_0.2-19 ggraph_2.1.0 ## [91] qvalue_2.32.0 ggplotify_0.1.2 cli_3.6.2 munsell_0.5.0 jquerylib_0.1.4 Rcpp_1.0.12 ## [97] png_0.1-8 parallel_4.3.1 blob_1.2.4 bitops_1.0-7 viridisLite_0.4.2 tidytree_0.4.5 ## [103] scales_1.3.0 purrr_1.0.2 crayon_1.5.2 rlang_1.1.3 cowplot_1.1.3 fastmatch_1.1-4 ## [109] KEGGREST_1.40.1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
