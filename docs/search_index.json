[["index.html", "Omics Data Analysis Chapter 1 Introduction 1.1 How to deal with R 1.2 Assignment and grading", " Omics Data Analysis Dmitrii Smirnov, Skolkovo Institute of Science and Technology 2024-02-13 Chapter 1 Introduction This bookdown will consist of three seminars for the following lectures delivering at “Omics Data Analysis” course at Skolkovo Institute of Science and Technology: Lecture 4: Differential Expression Analysis Lecture 9: Transcriptome Assembly Lecture 13: Lipidomics Data Analysis 1.1 How to deal with R Here is an brief guideline how to work with R on the course computational cluster or your own computer: https://docs.google.com/document/d/1vyR7T7nHnWgRfQPntLU3U2jaZFJia8zH/edit?usp=sharing&amp;ouid=118110925940360211775&amp;rtpof=true&amp;sd=true If your are not familiar with R programming language, you may find the following links useful: R-intro: https://cran.r-project.org/doc/manuals/r-release/R-intro.html Learning Statistics with R: https://learningstatisticswithr.com/book/introR.html Stepik course (in Russian): https://stepik.org/course/497/promo 1.2 Assignment and grading When you complete all the tasks please upload to Canvas: Report with plots, pictures, answers and explanations. Your code (txt/pdf/R markdown or something else readable) How it will be graded: * The maximum is 7 points. For missing step - minus 3.5 points. If the report/code is missing - 0 points. For each missing figure/plot - minus 2 points. For each missing answer to ❓ - minus 2 points. For any other mistake - minus 0.2 point. "],["input-dataset.html", "Chapter 2 Input dataset 2.1 Count table importing 2.2 DESeq2 object", " Chapter 2 Input dataset Today we will focus on the differential gene expression analysis to study the gene expression signatures of microglia from accelerated aging mice subjected to PBS (phosphate buffered saline) and LPS (lipopolysaccharides, activated microglia) treatments from Zhang et al., 2022 (https://doi.org/10.1186/s12974-022-02463-5). Our dataset includes 2 experimental groups of replicates: Control and KO microglia, where KO group corresponds to to the model of accelerated aging, caused by deficiency of the DNA-repair associated gene Ercc1. One half of the samples in each group we additionally treated with PBS and another half were treated with LPS to achieve pro-inflammatory microglial activation. Raw reads were already preprocessed by the authors of the original study, therefore we can skip a large part devoted to raw read processing and mapping (Figure 1), that you already studied during the previous lecture and start with a table of counts. The input dataset is accessible here: Course server: /home/d.smirnov/homework4/Data/Data.csv Yandex disk: https://disk.yandex.ru/d/2X3QgYRa5iqcFw Figure 1. DE analysis typical workflow Import libraries: library(dplyr) library(ggplot2) library(DESeq2) library(DOSE) library(pheatmap) library(tibble) library(clusterProfiler) 2.1 Count table importing We will start the analysis with uploading raw count data to the R workspace. data &lt;- read.csv(&quot;data/Data.csv&quot;, row.names = 1) The gene expression table has gene names in the rows and samples names in the columns. ‘Length’ column denotes a length of each annotated gene: paged_table(head(data)) Further we will need a meta table which maps our samples to the corresponding sample groups that we are investigating. Our metadata will include three columns of interest: “Genotype”, “Treatment” and “SampleID”. meta &lt;- colnames(data) %&gt;% .[-c(1)] %&gt;% strsplit(split = &#39;_&#39;) %&gt;% as.data.frame() %&gt;% t() rownames(meta) &lt;- colnames(data)[-c(1)] colnames(meta) &lt;- c(&quot;Genotype&quot;, &quot;Treatment&quot;, &quot;SampleID&quot;) meta &lt;- as.data.frame(meta) Check the generated meta table: knitr::kable(meta) Genotype Treatment SampleID KO_PBS_642 KO PBS 642 KO_PBS_641 KO PBS 641 KO_PBS_638 KO PBS 638 KO_LPS_600 KO LPS 600 KO_LPS_194 KO LPS 194 KO_LPS_193 KO LPS 193 Control_PBS_175 Control PBS 175 Control_PBS_171 Control PBS 171 Control_PBS_170 Control PBS 170 Control_LPS_185 Control LPS 185 Control_LPS_184 Control LPS 184 Control_LPS_149 Control LPS 149 Another important step is a filtering of the low- and non-expressed genes prior statistical analysis. Such genes contributes to the False Discovery Rate. We will keep only those genes having at least 10 counts in total across experimental replicates. data &lt;- data[rowSums(data[,-c(1)]) &gt; 10, ] 2.2 DESeq2 object Let’s start the main part of the analysis with creating the DESeqDataSet object. To create this object we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have two column we are interested in, that is \\(\\sim Treatment + Genotype\\). The \\(Genotype\\) is the main factor of interest, therefore it is in the end of the design formula. Create DESeq2Dataset object: dds &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Treatment + Genotype) ## converting counts to integer mode ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design formula are characters, ## converting to factors Check what is inside the object: dds ## class: DESeqDataSet ## dim: 22783 12 ## metadata(1): version ## assays(1): counts ## rownames(22783): ENSMUSG00000051951 ENSMUSG00000103377 ... ENSMUSG00000063897 ENSMUSG00000095742 ## rowData names(0): ## colnames(12): KO_PBS_642 KO_PBS_641 ... Control_LPS_184 Control_LPS_149 ## colData names(3): Genotype Treatment SampleID "],["cross.html", "Chapter 3 Normalization and Quality control 3.1 Normalization 3.2 Quality control", " Chapter 3 Normalization and Quality control 3.1 Normalization The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. To perform the median of ratios method of normalization1, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. Perform normalization: dds &lt;- estimateSizeFactors(dds) We can take a look at the normalization factor applied to each sample: sizeFactors(dds) ## KO_PBS_642 KO_PBS_641 KO_PBS_638 KO_LPS_600 KO_LPS_194 KO_LPS_193 ## 1.2295376 0.7077297 1.1883411 0.9626383 0.7803893 1.1168247 ## Control_PBS_175 Control_PBS_171 Control_PBS_170 Control_LPS_185 Control_LPS_184 Control_LPS_149 ## 1.3162828 1.0183880 1.0247178 0.9783637 1.0500173 0.9531096 Now, to retrieve the normalized counts matrix from dds, use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized=TRUE) These normalized counts are useful for the QC and visualization purposes, but the step with estimateSizeFactors() is done automatically by DESeq2 during differential expression analysis. 3.2 Quality control Next, we perform QC checks on the count data to help us ensure that the samples/replicates look good. To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. When using these unsupervised clustering methods, transformation of the normalized counts may improve the distances/clustering for visualization. First, let’s try the most simple method of log2 transformation and plot counts of the two first KO_PBS replicates as a scatter plot: nts &lt;- log2(assay(dds, normalized = TRUE)+1) ggplot(as.data.frame(nts), aes(x = KO_PBS_642, y = KO_PBS_641)) + geom_point()+ ggtitle(&#39;log2(x+1) transformation&#39;)+ theme_dose(16) Above you can see a nice example of heteroscedasticity in the data, illustrating the dependence of the variance on the mean count value. Instead, DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. Perform rlog-transformation: rld &lt;- rlog(dds, blind = TRUE) And this is how data looks like after rlog transformation: ggplot(as.data.frame(assay(rld)), aes(x = KO_PBS_642, y = KO_PBS_641)) + geom_point()+ ggtitle(&#39;rlog transformation&#39;)+ theme_dose(16) 3.2.1 Principal Component Analysis (PCA) PCA is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). We would expect that biological replicates cluster together on PC1 and/or PC2, and the samples from different treatment groups cluster separately. DESeq2 has a built-in function for plotting PCA plots, that uses ggplot2. It takes the rlog object as an input directly. The function plotPCA requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in). Below we will create a custom function to plot PCA: plotPCA.mystyle &lt;- function (object, ntop = 500, returnData = FALSE) { font.size &lt;- 18 rv &lt;- rowVars(assay(object)) r &lt;- assay(object) select &lt;- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))] pca &lt;- prcomp(t(assay(object)[select, ])) percentVar &lt;- pca$sdev^2/sum(pca$sdev^2) d1 &lt;- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], Genotype = meta$Genotype, Treatment = meta$Treatment, name = colnames(object)) ggplot(data = d1, aes_string(x = &quot;PC1&quot;, y = &quot;PC2&quot;)) + geom_point(aes_string(color = &quot;Genotype&quot;, shape = &quot;Treatment&quot;), size = 6) + xlab(paste0(&quot;PC1: &quot;, round(percentVar[1] * 100), &quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;, round(percentVar[2] * 100), &quot;% variance&quot;)) + theme_dose(font.size = font.size)+ #+ geom_label_repel(aes(label = colnames(data)), label.size = 0.1, box.padding = 0.2) theme( legend.key = element_rect(colour = NA, fill = NA), legend.title= element_blank(), legend.text=element_text(size=font.size-2) ) } Plot PCA graph: plotPCA.mystyle(rld) By default the function plotPCA.custom uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. Task 1: In the example above, we just plotted the graph for PC1 and PC2 values. Please change the function plotPCA.mystyle so it can produce score plots for PC1 and PC3. Also, provide an obtained plot and a brief explanation of it. (1 point). 3.2.2 Correlation Heatmap The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. Extract the rlog matrix from the object: rld_mat &lt;- assay(rld) Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: rld_cor &lt;- cor(rld_mat) Plot the correlation values as a heatmap: pheatmap(rld_cor, annotation = meta[,c(1,2)]) If you forgot how this method works you may check the lecture slides or watch this video: ↩︎ "],["differential-testing.html", "Chapter 4 Differential testing 4.1 DE analysis 4.2 Extracting significant genes", " Chapter 4 Differential testing Before the differential expression analysis we will combine \\(Genotype\\) and \\(Treatment\\) factors into one column, to create four groups for the design formula: meta$Factors &lt;- paste(meta$Genotype, meta$Treatment, sep = &#39;_&#39;) meta$Factors &lt;- factor(meta$Factors, levels = c(&quot;Control_PBS&quot;, &quot;Control_LPS&quot;, &quot;KO_PBS&quot;, &quot;KO_LPS&quot;)) Now re-create the DESeqDataSet object, but this time with a design formula consisting of \\(~Factors\\): dds_factors &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Factors) ## converting counts to integer mode Here we have only one factor for design formula, consisting of four different levels (Control_PBS, Control_LPS, KO_PBS, KO_LPS). In terms of linear models, the specified formula can be expressed as \\[expression = \\beta_0 + \\beta_1 Factor_{Control\\_LPS} + \\beta_2 Factor_{KO\\_PBS} + \\beta_3 Factor_{KO\\_LPS}\\] or in matrix notations: \\[\\, \\begin{pmatrix} Y_1\\\\ Y_2\\\\ \\vdots\\\\ Y_N \\end{pmatrix} = \\begin{pmatrix} 1 &amp;x_{11} &amp; x_{12} &amp; x_{13}\\\\ 1 &amp;x_{21} &amp; x_{22} &amp; x_{23}\\\\ \\vdots\\\\ 1 &amp; x_{N1} &amp; x_{N2} &amp; x_{N3} \\end{pmatrix} \\begin{pmatrix} \\beta_0\\\\ \\beta_1\\\\ \\beta_2\\\\ \\beta_3 \\end{pmatrix} + \\begin{pmatrix} \\varepsilon_1\\\\ \\varepsilon_2\\\\ \\vdots\\\\ \\varepsilon_N \\end{pmatrix} \\] where \\(X_{N\\times4}\\) is the design matrix, \\(\\mathbf{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3)^T\\) are estimated coefficients (log2 Fold Changes) and \\(\\mathbf{\\varepsilon} = (\\varepsilon_1, \\varepsilon_2, ..., \\varepsilon_N)^T\\) are residuals. Let’s check the model matrix in dds object: model.matrix(design(dds_factors), data = colData(dds_factors)) ## (Intercept) FactorsControl_LPS FactorsKO_PBS FactorsKO_LPS ## KO_PBS_642 1 0 1 0 ## KO_PBS_641 1 0 1 0 ## KO_PBS_638 1 0 1 0 ## KO_LPS_600 1 0 0 1 ## KO_LPS_194 1 0 0 1 ## KO_LPS_193 1 0 0 1 ## Control_PBS_175 1 0 0 0 ## Control_PBS_171 1 0 0 0 ## Control_PBS_170 1 0 0 0 ## Control_LPS_185 1 1 0 0 ## Control_LPS_184 1 1 0 0 ## Control_LPS_149 1 1 0 0 ## attr(,&quot;assign&quot;) ## [1] 0 1 1 1 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$Factors ## [1] &quot;contr.treatment&quot; 4.1 DE analysis All the steps of differential expression analysis can be done with a single call of the function DESeq(): dds_analysis &lt;- DESeq(dds_factors) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing Plot dispersion estimates: plotDispEsts(dds_analysis) To tell DESeq2 which groups we wish to compare, we supply the contrasts we would like to make using the contrast argument. contrast_pbs &lt;- c(&quot;Factors&quot;, &quot;KO_PBS&quot;, &quot;Control_PBS&quot;) contrast_lps &lt;- c(&quot;Factors&quot;, &quot;KO_LPS&quot;, &quot;Control_LPS&quot;) To build our results table we will use the results() function. res_unshrunken_pbs &lt;- results(dds_analysis, contrast=contrast_pbs, alpha = 0.05) res_unshrunken_lps &lt;- results(dds_analysis, contrast=contrast_lps, alpha = 0.05) To generate more accurate log2 fold change estimates, DESeq2 allows for the shrinkage of the log2 fold changes estimates toward zero when the information for a gene is low. res_pbs &lt;- lfcShrink(dds_analysis, contrast=contrast_pbs, res=res_unshrunken_pbs, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 res_lps &lt;- lfcShrink(dds_analysis, contrast=contrast_lps, res=res_unshrunken_lps, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 Check the DE results for the first comparison with PBS-treated samples: knitr::kable(head(res_pbs)) baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000051951 2.199116 0.2995143 0.5564338 0.9654189 0.3343350 NA ENSMUSG00000103377 1.543252 0.0000000 0.4451238 0.0000000 1.0000000 NA ENSMUSG00000103147 3.357070 -0.0725694 0.6653448 -0.1112250 0.9114379 NA ENSMUSG00000102331 2.149170 0.0000000 0.5917914 0.0000000 1.0000000 NA ENSMUSG00000102269 3.156919 0.7515637 0.6858511 1.0678169 0.2856031 NA ENSMUSG00000098104 66.394760 -0.0247357 0.3279316 -0.0756924 0.9396638 0.9780991 What are the columns of this table? baseMean is the mean gene expresion across all the samples in the data log2FoldChange represents differences for the comparison of interest (estimated \\(\\beta_i\\) coefficient) lfcSE is an uncertainty of \\(\\beta\\) estimate (\\(\\sigma_{\\beta_i}\\)), represented by standard error (SE) for the log2(Fold Change) stat is Z-statistic, also can be expressed as \\(Z = \\frac{\\beta_i}{\\sigma_{\\beta_i}}\\) pvalue means the raw p-value, derived from Wald Z-test, where \\(Z \\sim N(0, 1)\\), used to reject or accept the \\(H_0: \\beta_i = 0\\) padj is an adjusted p-value (FDR) To illustrate the effect of log2 foldchange shrinkage we will use the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored. plotMA(res_pbs, ylim=c(-3,5)) Task 2: Plot the unshrunken results and save the plot as pdf. Are there any differences between unshrunken and shrunken results? Provide a brief explanation (1 point). Check the results summary for PBS and LPS comparisons: summary(res_pbs, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 1658, 7.3% ## LFC &lt; 0 (down) : 1366, 6% ## outliers [1] : 58, 0.25% ## low counts [2] : 3976, 17% ## (mean count &lt; 4) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results summary(res_lps, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 2604, 11% ## LFC &lt; 0 (down) : 2650, 12% ## outliers [1] : 58, 0.25% ## low counts [2] : 3534, 16% ## (mean count &lt; 3) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results 4.2 Extracting significant genes Now we are ready to extract significant differentially expressed genes. We will define significant genes as those satisfying the |FDR p-value &lt; 0.05| and |log2(Fold Change)| &gt; 0.58: padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 Convert the results table into a tibble: res_pbs_tb &lt;- res_pbs %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() res_lps_tb &lt;- res_lps %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() Select significant genes: sig_pbs &lt;- res_pbs_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) sig_lps &lt;- res_lps_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) knitr::kable(head(sig_pbs)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.659849 -0.6181067 0.1498275 -4.125052 0.0000371 0.0006525 ENSMUSG00000098234 124.162031 1.2350160 0.3683580 3.356822 0.0007884 0.0081581 ENSMUSG00000104170 6.110599 -2.0618887 0.6755101 -3.124092 0.0017835 0.0158482 ENSMUSG00000082193 893.899515 0.6408058 0.1318862 4.858817 0.0000012 0.0000349 ENSMUSG00000043716 4483.398050 0.6343141 0.0997568 6.358617 0.0000000 0.0000000 ENSMUSG00000025921 339.426837 -0.7060598 0.2085612 -3.383875 0.0007147 0.0075408 knitr::kable(head(sig_lps)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.65985 -0.6522115 0.1512123 -4.313504 0.0000161 0.0001486 ENSMUSG00000103845 108.10608 -0.9919058 0.2279104 -4.353331 0.0000134 0.0001269 ENSMUSG00000076135 45.67683 0.8741142 0.3262561 2.675267 0.0074670 0.0302701 ENSMUSG00000061024 643.74312 0.6301914 0.1734137 3.632947 0.0002802 0.0018652 ENSMUSG00000079671 285.23809 -1.1868063 0.2880284 -4.125537 0.0000370 0.0003128 ENSMUSG00000098234 124.16203 0.9715333 0.3633901 2.668152 0.0076270 0.0307757 Intriguingly, the number of significant genes is almost twice more in the comparison with LPS compared to PBS-treated data. nrow(sig_pbs) ## [1] 2039 nrow(sig_lps) ## [1] 4045 Task 3: Perform DE analysis comparing LPS and PBS profiles: Control_LPS vs Control_PBS and KO_LPS vs KO_PBS. How many DE genes (FDP P-value &lt; 0.05 and |log2FC|&gt; 0.58) did you obtain for these comparisons (1 point). "],["gene-annotation.html", "Chapter 5 Gene annotation", " Chapter 5 Gene annotation Gene features in both input and DE tables are represented with their ENSEMBL identifiers, but it would be also useful to obtain an information about corresponding gene names, ENTREZ IDs and other types of description. To perform Gene ID conversion we will use mouse genome annotation from org.Mm.eg.db package library(org.Mm.eg.db) Use select() function to convert ENSEMBL IDs to gene names (“SYMBOL”) and Entrez identifiers (“ENTREZID”) mm &lt;- org.Mm.eg.db my.symbols &lt;- res_pbs_tb$gene map &lt;- select(mm, keys = my.symbols, columns = c(&quot;ENTREZID&quot;, &quot;SYMBOL&quot;, &quot;ENSEMBL&quot;), keytype = &quot;ENSEMBL&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns You could also notice warning 'select()' returned 1:many mapping between keys and columns, meaning that some genes have non-unique mapping between IDs. For example, Zfp969 genes has multiple ENSEMBL annotations: filter(map, SYMBOL == &#39;Zfp969&#39;)$ENSEMBL ## character(0) In addition, ENSMUSG00000078898 was also mapped to multiple gene names: filter(map, ENSEMBL == &#39;ENSMUSG00000078898&#39;)$SYMBOL ## [1] &quot;Zfp968&quot; First, we will combine DE result tables with the obtained gene annotation: res_pbs_tb &lt;- left_join(res_pbs_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) res_lps_tb &lt;- left_join(res_lps_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) Now DESeq2 output tables have two additional columns: paged_table(head(res_pbs_tb)) Next, we will get rid of duplicated ENSEMBL IDs: res_pbs_tb &lt;- res_pbs_tb[!duplicated(res_pbs_tb$gene),] res_lps_tb &lt;- res_lps_tb[!duplicated(res_lps_tb$gene),] Check if the number of genes in the output tables for both comparisons is equal: nrow(res_pbs_tb) == nrow(res_lps_tb) ## [1] TRUE Finally, get the annotation only for the differentially expressed genes: sig_pbs &lt;- res_pbs_tb %&gt;% filter(gene %in% sig_pbs$gene) sig_lps &lt;- res_lps_tb %&gt;% filter(gene %in% sig_lps$gene) "],["visualization.html", "Chapter 6 Visualization 6.1 Volcano plot 6.2 Heatmap of significant genes 6.3 Comparison with DAM markers", " Chapter 6 Visualization Once we obtained the lists of differentially expressed genes for each condition, it would be good to make sense of them. This chapter is devoted to the visual representation of DE results, that greatly helps with results interpretation. 6.1 Volcano plot The most standard way to visualize the obtained gene expression changes is volcano plot. This plot shows the direction of gene expression changes (up- or down-regulated) and also highlight the top DE genes. We will utilize EnhancedVolcano library: library(EnhancedVolcano) The volcano plot requires the information about gene log2(Fold Changes) for X-axis and corresponding adjusted p-values, plotted in Y-axis. In addition, you may specify the column in the DE table that can be used for gene annotation in the plot. Code below will execute EnhancedVolcano() function: p1 &lt;- EnhancedVolcano(res_pbs_tb, lab = res_pbs_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, PBS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) p2 &lt;- EnhancedVolcano(res_lps_tb, lab = res_lps_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, LPS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) cowplot::plot_grid(p1, p2, nrow = 1) 6.2 Heatmap of significant genes Another way to visualize DE genes and their changes in expression is using heatmap We also will extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap() function: Convert normalized_counts to a data frame and transfer the row names to a new column called “gene” normalized_counts &lt;- counts(dds_analysis, normalized = T) %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) Extract normalized expression for significant genes: norm_sig_pbs &lt;- normalized_counts %&gt;% filter(gene %in% sig_pbs$gene) %&gt;% column_to_rownames(&#39;gene&#39;) norm_sig_lps &lt;- normalized_counts %&gt;% filter(gene %in% sig_lps$gene) %&gt;% column_to_rownames(&#39;gene&#39;) Plot the heatmap: pheatmap(norm_sig_pbs, cluster_rows = T, show_rownames = F, annotation = meta[,c(1,2)], border_color = NA, fontsize = 10, scale = &quot;row&quot;, fontsize_row = 10, height = 10) 6.3 Comparison with DAM markers Disease-associated-microglia (DAM) is a microglia type associated with various neurodegeneration diseases (AD, ALS, aging) and characterized by a specific transcriptional program. We will work with DAM signatures described in Deczkowska et al., 2018 (https://doi.org/10.1016/j.cell.2018.05.003) and in the Figure 2. This signatures can be divided in three main groups or stages: markers of homeostatic microglia, Stage 2 DAM (independent on TREM2 signaling) signatures and markers of Stage 2 DAM of microglial activation, caused by TREM2 signaling. Figure 2: DAM stages in mouse: homeostatic microglia -&gt; Stage DAM 1 -&gt; Stage DAM 2. Figure was taken from Deczkowska et al., 2018. Task 4: Analyze changes in expression of DAM marker genes in the both PBS and LPS comparisons. Plot a heatmap of the DAM signature expression levels (0.5 points) and volcano plots for expression changes in DAM signatures for both comparisons (0.5 points). Do the observed changes in your data correspond to the changes in disease-associated microglia? Provide an explanation (0.5 points). "],["functional-analysis.html", "Chapter 7 Functional analysis 7.1 Gene Ontology (GO) analysis 7.2 Pathway analysis 7.3 Gene-Set Enrichment Analysis (GSEA) 7.4 Gene Set Enrichment Analysis with mSigDB", " Chapter 7 Functional analysis The main idea of the functional analysis is to connect observed changes in gene expression with associated altered cellular pathways and biological functions. Below we will try the most well-known methods allowing to gain some insight into biological interpretation of the obtained DE results. 7.1 Gene Ontology (GO) analysis Gene Ontology analysis is probably the most popular and widely-used method. The hypergeometric test, that is identical to one-sided Fisher’s exact test, is typically used for over-representation analysis and the p-value of the significance is calculated in the following way: \\[ p = 1 - \\sum_{i = 0}^{k-1} \\frac{\\binom{M}{i} \\binom{N-M}{n-i}}{\\binom{N}{n}} \\] where \\(N\\) is a total number of genes in the background \\(M\\) is a number of genes in the background that are also in the GO category \\(n\\) is a total number of DE genes \\(k\\) is number of DE genes that are also in the GO category While the over-representation analysis can be easily done with many packages in R, the most popular is ClusterProfiler. GO analysis with ClusterProfiler can be easily done with enrichGO function: ego_pbs &lt;- enrichGO(gene = sig_pbs$gene, universe = res_pbs_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) ego_lps &lt;- enrichGO(gene = sig_lps$gene, universe = res_lps_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) We will use boxplots to visualize the enriched categories: cowplot::plot_grid(barplot(ego_pbs), barplot(ego_lps), nrow = 1) 7.2 Pathway analysis Over-representation analysis using reference data on KEGG pathways can be done in a similar way, but now we must use enrichKEGG function and utilize NCBI ENTREZ IDs as input: ekegg_pbs &lt;- enrichKEGG(gene = na.omit(sig_pbs$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe=na.omit(res_pbs_tb$ENTREZID)) ## Reading KEGG annotation online: &quot;https://rest.kegg.jp/link/mmu/pathway&quot;... ## Reading KEGG annotation online: &quot;https://rest.kegg.jp/list/pathway/mmu&quot;... ekegg_lps &lt;- enrichKEGG(gene = na.omit(sig_lps$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe=na.omit(res_lps_tb$ENTREZID)) library(enrichplot) Since recently, the description of KEGG pathways in the clusterProfiler output data include the part related to a species name, which is - Mus musculus .(house mouse). in this case. This annoying text complicates visualization of the enriched pathways, so we will get rid of it: ekegg_pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_pbs@result$Description) ekegg_lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_lps@result$Description) Another (and a little bit more complex) way to visualize pathway enrichment results is to use upsetplots, showing co-occurring DE gene sets in respect to the altered pathways they associated with: ups_pbs &lt;- upsetplot(ekegg_pbs) ups_lps &lt;- upsetplot(ekegg_lps) ups_pbs ups_lps 7.3 Gene-Set Enrichment Analysis (GSEA) Unlike hypergeometric distribution based methods, GSEA works in the assumption that even small and not significant, but coordinated changes in gene expression can have impact on cellular pathways. Therefore, GSEA uses statistics of all the genes in a dataset, taking log2 Fold Changes as an input. Figure 3: The general principle of GSEA. The figure was taken from Subramanian et al., (2005) https://doi.org/10.1073/pnas.0506580102 Since GSEA interpretation in clusterProfiler rely on NCBI ENTREZ IDs, we will filter out genes not annotated in ENTREZ: pbs_filtered &lt;- filter(res_pbs_tb, ENTREZID != &quot;NA&quot;) lps_filtered &lt;- filter(res_lps_tb, ENTREZID != &quot;NA&quot;) Select gene log2(Fold Changes) and assign NCBI ENTREZ IDs as names of the vectors: foldchanges.pbs &lt;- pbs_filtered$log2FoldChange names(foldchanges.pbs) &lt;- as.character(pbs_filtered$ENTREZID) foldchanges.lps &lt;- lps_filtered$log2FoldChange names(foldchanges.lps) &lt;- as.character(lps_filtered$ENTREZID) Sort fold changes: foldchanges.pbs &lt;- sort(foldchanges.pbs, decreasing = TRUE) foldchanges.lps &lt;- sort(foldchanges.lps, decreasing = TRUE) Now, we can run gseKEGG() function with sorted fold changes as input and using default parameters gseaKEGG.pbs &lt;- gseKEGG(geneList = foldchanges.pbs, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using ## nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying ## to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the ## nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.2% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene ## names, fgsea may produce unexpected results. gseaKEGG.lps &lt;- gseKEGG(geneList = foldchanges.lps, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using ## nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying ## to run fgseaSimple. It is recommended to use fgseaMultilevel. To run fgseaMultilevel, you need to remove the ## nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.21% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene ## names, fgsea may produce unexpected results. Remove the species name in the pathway description again: gseaKEGG.pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.pbs@result$Description) gseaKEGG.lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.lps@result$Description) Check the results for both comparisons: paged_table(gseaKEGG.pbs@result) paged_table(gseaKEGG.lps@result) Apart from the adjusted p-values, enrichment score is another important characteristic of the altered pathways, reflecting the degree of which gene sets are over-represented at the top or at the bottom of the input ranked gene lists. You may find the corresponding values in enrichmentScore column of gseaKEGG.pbs and gseaKEGG.lps tables. Below is a GSEA plot for three manually selected enriched pathway from the PBS comparison: gseaplot2(gseaKEGG.pbs, geneSetID = c(15, 23, 29), pvalue_table = TRUE, color = c(&quot;#E495A5&quot;, &quot;#86B875&quot;, &quot;#7DB0DD&quot;), ES_geom = &quot;dot&quot;) 7.4 Gene Set Enrichment Analysis with mSigDB In the section above we used GO terms and KEGG pathways to perform enrichment analyses, but sometimes it is needed to compare gene expression changes against other gene sets, such as signatures or markers of the various diseases and biological processes. A possible solution is to use Molecular Signatures Database (mSigDB) represents the curated lists of gene sets, divided in 9 main collections: H: Hallmark gene sets C1: Positional gene sets C2: Curated gene sets C3: Motif gene sets C4: Computational gene sets C5: Gene Ontology gene sets C6: Oncogenic signatures gene sets C7: Immunologic signatures C8: Cell type signatures In R this database is already available through the msigdbr package: library(msigdbr) While mSigDB contains annotated gene sets for many species (you can get a list of them with msigdbr_show_species()), we will specify ‘mouse’ to retrieve mouse-related sets for the Hallmark gene sets: msig_h &lt;- msigdbr(species = &quot;mouse&quot;, category = &quot;H&quot;) Next, prepare an input reference table for enrichment analysis: msigdbr_t2g &lt;- msig_h %&gt;% dplyr::distinct(gs_name, ensembl_gene) %&gt;% as.data.frame() This table consist of two columns, one for gene set names (specific terms) and another one for the corresponding ENSEMBL IDs: paged_table(head(msigdbr_t2g)) Run the over-presentation analysis on significant genes with prepared term-to-gene table using enricher() function: hallmarks.pbs &lt;- enricher(gene = sig_pbs$gene, TERM2GENE = msigdbr_t2g) hallmarks.lps &lt;- enricher(gene = sig_lps$gene, TERM2GENE = msigdbr_t2g) Visualize the obtained enriched terms for PBS comparison: dotplot(hallmarks.pbs) … and for LPS comparison: dotplot(hallmarks.lps) To run the GSEA analysis with mSigDB terms we must select NCBI ENTREZ IDs instead of ENSEMBL ones: msigdbr_t2g &lt;- msig_h %&gt;% dplyr::distinct(gs_name, entrez_gene) Now execute GSEA function with foldchanges.pbs gene list and re-generated term-to-gene annotation: gsea_h_pbs &lt;- GSEA(foldchanges.pbs, TERM2GENE = msigdbr_t2g) ## preparing geneSet collections... ## GSEA analysis... ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.2% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene ## names, fgsea may produce unexpected results. ## Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize, : For some pathways, in ## reality P-values are less than 1e-10. You can set the `eps` argument to zero for better estimation. ## leading edge analysis... ## done... Check out the enriched terms: paged_table(head(gsea_h_pbs)) An essential part of DE analysis is the validation of the obtained gene expression changes with custom gene sets, identified by other researches in similar experiments. Here we will use previously described enrichment methods to compare our changes against a list of DAM metabolites. Task 5: Perform GSEA on foldchanges.pbs and foldchanges.lps lists using DAM-related genes as an argument for TERM2GENE = ... in GSEA() function (1.5 point). Task 6: So far we did the enrichment analysis for all the obtained DE genes per comparison, but sometimes it is useful to focus on the specific groups of DE genes. For example, one can split DE gene set into down- or up-regulated subsets and test them with the enrichment methods, but in this task you will be asked to accomplish a more complicated, but, in the same time, more interesting analysis: First, perform clustering of your DE genes (you can use DE set for the comparison you prefer most) to identify groups of genes with similar expression trends. The most straightforward method here is hierarchical clustering, but you can also any other adequate gene clustering methods you like. Next, choose the number of clusters based on some criteria. It can be the Gap-Statistics, the Silhouette or any other appropriate method you like. Perform the enrichment analysis (enrichGO/enrichKEGG) on the groups of genes you like most, two or three groups will be enough. Provide the plots and also comment on the enrichment results obtained. As it was mentioned, this task is more challenging, but is it close as possible to the real research tasks relevant to the DE results interpretation. This task will give you 1 point. Have fun! "],["transcriptome-de-novo-assembly.html", "Chapter 8 Transcriptome de novo assembly", " Chapter 8 Transcriptome de novo assembly To be added. "],["lipidomics-data-analysis.html", "Chapter 9 Lipidomics Data Analysis", " Chapter 9 Lipidomics Data Analysis To be added. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
