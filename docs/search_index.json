[["index.html", "Omics Data Analysis Chapter 1 Introduction 1.1 How to deal with R 1.2 Assignment and grading", " Omics Data Analysis Dmitrii Smirnov 2024-02-08 Chapter 1 Introduction This bookdown will consist of three seminars for the following lectures delivering at “Omics Data Analysis” course at Skolkovo Institute of Science and Technology: Lecture 4: Differential Expression Analysis Lecture 9: Transcriptome Assembly Lecture 13: Lipidomics Data Analysis 1.1 How to deal with R Here is an brief guideline how to work with R on the course computational cluster or your own computer: https://docs.google.com/document/d/1vyR7T7nHnWgRfQPntLU3U2jaZFJia8zH/edit?usp=sharing&amp;ouid=118110925940360211775&amp;rtpof=true&amp;sd=true If your are not familiar with R programming language, you may find the following links useful: R-intro: https://cran.r-project.org/doc/manuals/r-release/R-intro.html Learning Statistics with R: https://learningstatisticswithr.com/book/introR.html Stepik course (in Russian): https://stepik.org/course/497/promo 1.2 Assignment and grading When you complete all the tasks please upload to Canvas: Report with plots, pictures, answers and explanations. Your code (txt/pdf/R markdown or something else readable) How it will be graded: * The maximum is 7 points. For missing step - minus 5 points. If the report/code is missing - 0 points. For each missing figure/plot - minus 2 points. For each missing answer to ❓ - minus 2 points. For any other mistake - minus 0.2 point. "],["input-dataset.html", "Chapter 2 Input dataset 2.1 Count table importing 2.2 DESeq2 object", " Chapter 2 Input dataset Today we will focus on the differential gene expression analysis to study the molecular signatures of Amyloid-β toxicity in yeast using the data obtained from GEO database (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE128905). There are 2 experimental groups of replicates: Control and Aβ42 (yeasts expressing Aβ42 peptide) with 3 replicates per group. Raw reads were already preprocessed and Salmon pseudocounts are accessible here: /home/d.smirnov/homework4/SalmonOutput Import libraries: library(dplyr) library(ggplot2) library(DESeq2) library(DOSE) library(pheatmap) library(tibble) library(clusterProfiler) 2.1 Count table importing We will start the analysis with uploading raw count data to the R workspace. data &lt;- read.csv(&quot;../../Data.csv&quot;, row.names = 1) The gene expression table has gene names in the rows and samples names in the columns. ‘Length’ column denotes a length of each annotated gene: head(data) ## Length KO_PBS_642 KO_PBS_641 KO_PBS_638 KO_LPS_600 KO_LPS_194 KO_LPS_193 Control_PBS_175 Control_PBS_171 Control_PBS_170 Control_LPS_185 ## ENSMUSG00000102693 1070 0 0 0 0 0 0 0 0 0 0 ## ENSMUSG00000064842 110 0 0 0 0 0 0 0 0 0 0 ## ENSMUSG00000051951 6094 4 0 0 0 0 0 0 0 0 1 ## ENSMUSG00000102851 480 0 0 0 0 0 0 0 0 0 0 ## ENSMUSG00000103377 2819 0 0 0 4 0 0 0 0 0 12 ## ENSMUSG00000104017 2233 0 0 0 0 1 0 0 0 0 0 ## Control_LPS_184 Control_LPS_149 ## ENSMUSG00000102693 0 0 ## ENSMUSG00000064842 0 0 ## ENSMUSG00000051951 10 12 ## ENSMUSG00000102851 0 0 ## ENSMUSG00000103377 0 2 ## ENSMUSG00000104017 0 5 Further we will need a meta table which maps our samples to the corresponding sample groups that we are investigating. Our metadata will include three columns of interest: “Genotype”, “Treatment” and “SampleID”. meta &lt;- colnames(data) %&gt;% .[-c(1)] %&gt;% strsplit(split = &#39;_&#39;) %&gt;% as.data.frame() %&gt;% t() rownames(meta) &lt;- colnames(data)[-c(1)] colnames(meta) &lt;- c(&quot;Genotype&quot;, &quot;Treatment&quot;, &quot;SampleID&quot;) meta &lt;- as.data.frame(meta) Another important step is a filtering of the low- and non-expressed genes prior statistical analysis. Such genes contributes to the False Discovery Rate. We will keep only those genes having at least 10 counts in total across experimental replicates. data &lt;- data[rowSums(data[,-c(1)]) &gt; 10, ] 2.2 DESeq2 object Let’s start the main part of the analysis with creating the DESeqDataSet object. To create this object we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have two column we are interested in, that is \\(\\sim Treatment + Genotype\\). The \\(Genotype\\) is the main factor of interest, therefore it is in the end of the design formula. Create DESeq2Dataset object: dds &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Genotype + Treatment) ## converting counts to integer mode ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design formula are characters, converting to factors dds ## class: DESeqDataSet ## dim: 22783 12 ## metadata(1): version ## assays(1): counts ## rownames(22783): ENSMUSG00000051951 ENSMUSG00000103377 ... ENSMUSG00000063897 ENSMUSG00000095742 ## rowData names(0): ## colnames(12): KO_PBS_642 KO_PBS_641 ... Control_LPS_184 Control_LPS_149 ## colData names(3): Genotype Treatment SampleID "],["cross.html", "Chapter 3 Normalization and Quality control 3.1 Normalization 3.2 Quality control", " Chapter 3 Normalization and Quality control 3.1 Normalization The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. To perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. Perform normalization: dds &lt;- estimateSizeFactors(dds) We can take a look at the normalization factor applied to each sample: sizeFactors(dds) ## KO_PBS_642 KO_PBS_641 KO_PBS_638 KO_LPS_600 KO_LPS_194 KO_LPS_193 Control_PBS_175 Control_PBS_171 Control_PBS_170 Control_LPS_185 ## 1.2295376 0.7077297 1.1883411 0.9626383 0.7803893 1.1168247 1.3162828 1.0183880 1.0247178 0.9783637 ## Control_LPS_184 Control_LPS_149 ## 1.0500173 0.9531096 Now, to retrieve the normalized counts matrix from dds, use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized=TRUE) 3.2 Quality control Next, we perform QC checks on the count data to help us ensure that the samples/replicates look good. To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. When using these unsupervised clustering methods, log2-transformation of the normalized counts improves the distances/clustering for visualization. DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. Perform rlog-transformation: rld &lt;- rlog(dds, blind = TRUE) 3.2.1 Principal Component Analysis (PCA) PCA is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). We would expect that biological replicates cluster together on PC1 and/or PC2, and the samples from different treatment groups cluster separately. DESeq2 has a built-in function for plotting PCA plots, that uses ggplot2. It takes the rlog object as an input directly. The function plotPCA requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in). Below we will create a custom function to plot PCA: plotPCA.mystyle &lt;- function (object, ntop = 2400, returnData = FALSE) { font.size &lt;- 18 rv &lt;- rowVars(assay(object)) r &lt;- assay(object) select &lt;- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))] pca &lt;- prcomp(t(assay(object)[select, ])) percentVar &lt;- pca$sdev^2/sum(pca$sdev^2) d1 &lt;- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], Genotype = meta$Genotype, Treatment = meta$Treatment, name = colnames(object)) if (returnData) { attr(d, &quot;percentVar&quot;) &lt;- percentVar[1:2] return(d) } ggplot(data = d1, aes_string(x = &quot;PC1&quot;, y = &quot;PC2&quot;)) + geom_point(aes_string(color = &quot;Genotype&quot;, shape = &quot;Treatment&quot;), size = 6) + xlab(paste0(&quot;PC1: &quot;, round(percentVar[1] * 100), &quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;, round(percentVar[2] * 100), &quot;% variance&quot;)) + theme_dose(font.size = font.size)+ #+ geom_label_repel(aes(label = colnames(data)), label.size = 0.1, box.padding = 0.2) theme( legend.key = element_rect(colour = NA, fill = NA), legend.title= element_blank(), legend.text=element_text(size=font.size-2) ) } Plot PCA graph: plotPCA.mystyle(rld) By default the function plotPCA.custom uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. 3.2.2 Correlation Heatmap (PCA) The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. Extract the rlog matrix from the object: rld_mat &lt;- assay(rld) Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: rld_cor &lt;- cor(rld_mat) Plot the correlation values as a heatmap: pheatmap(rld_cor, annotation = meta[,c(1,2)]) "],["differential-testing.html", "Chapter 4 Differential testing", " Chapter 4 Differential testing All the steps of differential expression analysis can be done with a single call of the function DESeq(). meta$Factors &lt;- paste(meta$Genotype, meta$Treatment, sep = &#39;_&#39;) dds_factors &lt;- DESeqDataSetFromMatrix(countData = round(data[,-c(1)]), colData = meta, design = ~ Factors) ## converting counts to integer mode ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design formula are characters, converting to factors dds_analysis &lt;- DESeq(dds_factors) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing Plot dispertion estimates: plotDispEsts(dds_analysis) To tell DESeq2 which groups we wish to compare, we supply the contrasts we would like to make using the contrast argument. contrast_pbs &lt;- c(&quot;Factors&quot;, &quot;KO_PBS&quot;, &quot;Control_PBS&quot;) contrast_lps &lt;- c(&quot;Factors&quot;, &quot;KO_LPS&quot;, &quot;Control_LPS&quot;) To build our results table we will use the results() function. res_unshrunken_pbs &lt;- results(dds_analysis, contrast=contrast_pbs, alpha = 0.05) res_unshrunken_lps &lt;- results(dds_analysis, contrast=contrast_lps, alpha = 0.05) To generate more accurate log2 fold change estimates, DESeq2 allows for the shrinkage of the log2 fold changes estimates toward zero when the information for a gene is low. res_pbs &lt;- lfcShrink(dds_analysis, contrast=contrast_pbs, res=res_unshrunken_pbs, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 res_lps &lt;- lfcShrink(dds_analysis, contrast=contrast_lps, res=res_unshrunken_lps, type=&#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 To illustrate the effect of log2 foldchange shrinkage we will use the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored. plotMA(res_pbs, ylim=c(-3,5)) Task 1: Plot the unshrunken results and save the plot as pdf. Are there any differences between unshrunken and shrunken results? Provide a brief explanation. Check the results summary for PBS and LPS comparisons: summary(res_pbs, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 1658, 7.3% ## LFC &lt; 0 (down) : 1366, 6% ## outliers [1] : 58, 0.25% ## low counts [2] : 3976, 17% ## (mean count &lt; 4) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results summary(res_lps, alpha = 0.05) ## ## out of 22783 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 2604, 11% ## LFC &lt; 0 (down) : 2650, 12% ## outliers [1] : 58, 0.25% ## low counts [2] : 3534, 16% ## (mean count &lt; 3) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results Now we are ready to extract significant differentially expressed genes. We will define significant genes as those satisfying the |FDR p-value &lt; 0.05| and |log2(Fold Change)| &gt; 0.58: padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 Convert the results table into a tibble: res_pbs_tb &lt;- res_pbs %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() res_lps_tb &lt;- res_lps %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() Select significant genes: sig_pbs &lt;- res_pbs_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) sig_lps &lt;- res_lps_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt;= lfc.cutoff) knitr::kable(head(sig_pbs)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.659849 -0.6181067 0.1498275 -4.125053 0.0000371 0.0006525 ENSMUSG00000098234 124.162031 1.2350151 0.3683577 3.356820 0.0007884 0.0081581 ENSMUSG00000104170 6.110599 -2.0618792 0.6755077 -3.124092 0.0017835 0.0158482 ENSMUSG00000082193 893.899515 0.6408057 0.1318862 4.858816 0.0000012 0.0000349 ENSMUSG00000043716 4483.398050 0.6343141 0.0997568 6.358617 0.0000000 0.0000000 ENSMUSG00000025921 339.426837 -0.7060597 0.2085612 -3.383876 0.0007147 0.0075408 knitr::kable(head(sig_lps)) gene baseMean log2FoldChange lfcSE stat pvalue padj ENSMUSG00000025907 1336.65985 -0.6522114 0.1512123 -4.313503 0.0000161 0.0001486 ENSMUSG00000103845 108.10608 -0.9919055 0.2279103 -4.353331 0.0000134 0.0001269 ENSMUSG00000076135 45.67683 0.8741138 0.3262560 2.675268 0.0074669 0.0302700 ENSMUSG00000061024 643.74312 0.6301913 0.1734136 3.632948 0.0002802 0.0018652 ENSMUSG00000079671 285.23809 -1.1868058 0.2880283 -4.125536 0.0000370 0.0003128 ENSMUSG00000098234 124.16203 0.9715327 0.3633899 2.668153 0.0076269 0.0307756 Intriguingly, the number of significant genes is almost twice more in the comparison with LPS compared to PBS-treated data. nrow(sig_pbs) ## [1] 2039 nrow(sig_lps) ## [1] 4045 "],["gene-annotation.html", "Chapter 5 Gene annotation", " Chapter 5 Gene annotation Gene features in both input and DE tables are represented with their ENSEMBL identifiers, but it would be also useful to obtain an information about corresponding gene names, ENTREZ IDs and other types of description. To perform Gene ID conversion we will use mouse genome annotation from org.Mm.eg.db package library(org.Mm.eg.db) Use select() function to convert ENSEMBL IDs to gene names (“SYMBOL”) and Entrez identifiers (“ENTREZID”) mm &lt;- org.Mm.eg.db my.symbols &lt;- res_pbs_tb$gene map &lt;- select(mm, keys = my.symbols, columns = c(&quot;ENTREZID&quot;, &quot;SYMBOL&quot;, &quot;ENSEMBL&quot;), keytype = &quot;ENSEMBL&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns You could also notice warning 'select()' returned 1:many mapping between keys and columns, meaning that some genes have non-unique mapping between IDs. For example, Zfp969 genes has multiple ENSEMBL annotations: filter(map, SYMBOL == &#39;Zfp969&#39;)$ENSEMBL ## [1] &quot;ENSMUSG00000078898&quot; &quot;ENSMUSG00000095545&quot; &quot;ENSMUSG00000089756&quot; &quot;ENSMUSG00000095199&quot; In addition, ENSMUSG00000078898 was also mapped to multiple gene names: filter(map, ENSEMBL == &#39;ENSMUSG00000078898&#39;)$SYMBOL ## [1] &quot;Zfp968&quot; &quot;Zfp969&quot; First, we will combine DE result tables with the obtained gene annotation: res_pbs_tb &lt;- left_join(res_pbs_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) res_lps_tb &lt;- left_join(res_lps_tb, map, by = c(&quot;gene&quot; = &quot;ENSEMBL&quot;)) Now DESeq2 output tables have two additional columns: paged_table(head(res_pbs_tb)) Next, we will get rid of duplicated ENSEMBL IDs: res_pbs_tb &lt;- res_pbs_tb[!duplicated(res_pbs_tb$gene),] res_lps_tb &lt;- res_lps_tb[!duplicated(res_lps_tb$gene),] Check if the number of genes in the output tables for both comparisons is equal: nrow(res_pbs_tb) == nrow(res_lps_tb) ## [1] TRUE Finally, get the annotation only for the differentially expressed genes: sig_pbs &lt;- res_pbs_tb %&gt;% filter(gene %in% sig_pbs$gene) sig_lps &lt;- res_lps_tb %&gt;% filter(gene %in% sig_lps$gene) "],["visualization.html", "Chapter 6 Visualization 6.1 Volcano plot", " Chapter 6 Visualization 6.1 Volcano plot library(EnhancedVolcano) EnhancedVolcano(res_pbs_tb, lab = res_pbs_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, PBS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) EnhancedVolcano(res_lps_tb, lab = res_lps_tb$SYMBOL, x = &#39;log2FoldChange&#39;, y = &#39;padj&#39;, title = &#39;KO vs Control, LPS&#39;, subtitle = NULL, pCutoff = 0.05, FCcutoff = 0.58) "],["functional-analysis.html", "Chapter 7 Functional analysis 7.1 Gene Ontology (GO) analysis 7.2 Pathway analysis 7.3 Gene-Set Enrichment Analysis (GSEA) 7.4 mSigDb enrichment analysis", " Chapter 7 Functional analysis 7.1 Gene Ontology (GO) analysis ego_pbs &lt;- enrichGO(gene = sig_pbs$gene, universe = res_pbs_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) ego_lps &lt;- enrichGO(gene = sig_lps$gene, universe = res_lps_tb$gene, keyType = &quot;ENSEMBL&quot;, OrgDb = org.Mm.eg.db, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05) print(barplot(ego_pbs)) print(barplot(ego_lps)) 7.2 Pathway analysis ekegg_pbs &lt;- enrichKEGG(gene = na.omit(sig_pbs$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe=na.omit(res_pbs_tb$ENTREZID)) ekegg_lps &lt;- enrichKEGG(gene = na.omit(sig_lps$ENTREZID), organism = &#39;mmu&#39;, pvalueCutoff = 0.05, universe=na.omit(res_lps_tb$ENTREZID)) library(enrichplot) ekegg_pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_pbs@result$Description) ekegg_lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, ekegg_lps@result$Description) ups_pbs &lt;- upsetplot(ekegg_pbs) ups_lps &lt;- upsetplot(ekegg_lps) print(ups_pbs) ups_lps 7.3 Gene-Set Enrichment Analysis (GSEA) pbs_filtered &lt;- filter(res_pbs_tb, ENTREZID != &quot;NA&quot;) lps_filtered &lt;- filter(res_lps_tb, ENTREZID != &quot;NA&quot;) foldchanges.pbs &lt;- pbs_filtered$log2FoldChange names(foldchanges.pbs) &lt;- as.character(pbs_filtered$ENTREZID) foldchanges.lps &lt;- lps_filtered$log2FoldChange names(foldchanges.lps) &lt;- as.character(lps_filtered$ENTREZID) foldchanges.pbs &lt;- sort(foldchanges.pbs, decreasing = TRUE) foldchanges.lps &lt;- sort(foldchanges.lps, decreasing = TRUE) gseaKEGG.pbs &lt;- gseKEGG(geneList = foldchanges.pbs, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying to run fgseaSimple. It is recommended to use ## fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.21% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene names, fgsea may produce unexpected results. gseaKEGG.lps &lt;- gseKEGG(geneList = foldchanges.lps, pAdjustMethod = &quot;fdr&quot;, organism = &quot;mmu&quot;, nPerm = 2000, minGSSize = 10, pvalueCutoff = 0.05, verbose = FALSE, seed = TRUE) ## Warning in .GSEA(geneList = geneList, exponent = exponent, minGSSize = minGSSize, : We do not recommend using nPerm parameter incurrent and future releases ## Warning in fgsea(pathways = geneSets, stats = geneList, nperm = nPerm, minSize = minGSSize, : You are trying to run fgseaSimple. It is recommended to use ## fgseaMultilevel. To run fgseaMultilevel, you need to remove the nperm argument in the fgsea function call. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.22% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are duplicate gene names, fgsea may produce unexpected results. gseaKEGG.pbs@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.pbs@result$Description) gseaKEGG.lps@result$Description &lt;- sub(&quot; - Mus musculus .(house mouse).&quot;, &quot;&quot;, gseaKEGG.lps@result$Description) paged_table(gseaKEGG.pbs@result) paged_table(gseaKEGG.lps@result) gseaplot2(gseaKEGG.pbs, geneSetID = c(15, 23, 29), pvalue_table = TRUE, color = c(&quot;#E495A5&quot;, &quot;#86B875&quot;, &quot;#7DB0DD&quot;), ES_geom = &quot;dot&quot;) 7.4 mSigDb enrichment analysis library(msigdbr) all_gene_sets = msigdbr(species = &quot;Mus musculus&quot;) msig_h &lt;- msigdbr(species = &quot;mouse&quot;, category = &quot;H&quot;) msigdbr_t2g &lt;- msig_h %&gt;% dplyr::distinct(gs_name, ensembl_gene) %&gt;% as.data.frame() hallmarks.pbs &lt;- enricher(gene = sig_pbs$gene, TERM2GENE = msigdbr_t2g) hallmarks.lps &lt;- enricher(gene = sig_lps$gene, TERM2GENE = msigdbr_t2g) dotplot(hallmarks.pbs) dotplot(hallmarks.lps) "],["transcriptome-de-novo-assembly.html", "Chapter 8 Transcriptome de novo assembly", " Chapter 8 Transcriptome de novo assembly To be added. "],["lipidomics-data-analysis.html", "Chapter 9 Lipidomics Data Analysis", " Chapter 9 Lipidomics Data Analysis To be added. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
